{"ast":null,"code":"import _createClass from \"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { Directive, ElementRef, EventEmitter, HostBinding, HostListener, Input, NgZone, Output, Renderer2, ContentChild, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\nimport * as ɵngcc0 from '@angular/core';\nvar DROP_EFFECTS =\n/** @type {?} */\n[\"move\", \"copy\", \"link\"];\n/** @type {?} */\n\nvar CUSTOM_MIME_TYPE = \"application/x-dnd\";\n/** @type {?} */\n\nvar JSON_MIME_TYPE = \"application/json\";\n/** @type {?} */\n\nvar MSIE_MIME_TYPE = \"Text\";\n/**\n * @param {?} mimeType\n * @return {?}\n */\n\nfunction mimeTypeIsCustom(mimeType) {\n  return mimeType.substr(0, CUSTOM_MIME_TYPE.length) === CUSTOM_MIME_TYPE;\n}\n/**\n * @param {?} event\n * @return {?}\n */\n\n\nfunction getWellKnownMimeType(event) {\n  if (event.dataTransfer) {\n    /** @type {?} */\n    var types = event.dataTransfer.types; // IE 9 workaround.\n\n    if (!types) {\n      return MSIE_MIME_TYPE;\n    }\n\n    for (var i = 0; i < types.length; i++) {\n      if (types[i] === MSIE_MIME_TYPE || types[i] === JSON_MIME_TYPE || mimeTypeIsCustom(types[i])) {\n        return types[i];\n      }\n    }\n  }\n\n  return null;\n}\n/**\n * @param {?} event\n * @param {?} data\n * @param {?} effectAllowed\n * @return {?}\n */\n\n\nfunction setDragData(event, data, effectAllowed) {\n  // Internet Explorer and Microsoft Edge don't support custom mime types, see design doc:\n  // https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\n\n  /** @type {?} */\n  var mimeType = CUSTOM_MIME_TYPE + (data.type ? \"-\" + data.type : \"\");\n  /** @type {?} */\n\n  var dataString = JSON.stringify(data);\n\n  try {\n    event.dataTransfer.setData(mimeType, dataString);\n  } catch (e) {\n    //   Setting a custom MIME type did not work, we are probably in IE or Edge.\n    try {\n      event.dataTransfer.setData(JSON_MIME_TYPE, dataString);\n    } catch (e) {\n      //   We are in Internet Explorer and can only use the Text MIME type. Also note that IE\n      //   does not allow changing the cursor in the dragover event, therefore we have to choose\n      //   the one we want to display now by setting effectAllowed.\n\n      /** @type {?} */\n      var effectsAllowed = filterEffects(DROP_EFFECTS, effectAllowed);\n      event.dataTransfer.effectAllowed = effectsAllowed[0];\n      event.dataTransfer.setData(MSIE_MIME_TYPE, dataString);\n    }\n  }\n}\n/**\n * @param {?} event\n * @param {?} dragIsExternal\n * @return {?}\n */\n\n\nfunction getDropData(event, dragIsExternal) {\n  // check if the mime type is well known\n\n  /** @type {?} */\n  var mimeType = getWellKnownMimeType(event); // drag did not originate from [dndDraggable]\n\n  if (dragIsExternal === true) {\n    if (mimeType !== null && mimeTypeIsCustom(mimeType)) {\n      // the type of content is well known and safe to handle\n      return JSON.parse(event.dataTransfer.getData(mimeType));\n    } // the contained data is unknown, let user handle it\n\n\n    return {};\n  } // the type of content is well known and safe to handle\n\n\n  return JSON.parse(event.dataTransfer.getData(mimeType));\n}\n/**\n * @param {?} effects\n * @param {?} allowed\n * @return {?}\n */\n\n\nfunction filterEffects(effects, allowed) {\n  if (allowed === \"all\" || allowed === \"uninitialized\") {\n    return effects;\n  }\n\n  return effects.filter(\n  /**\n  * @param {?} effect\n  * @return {?}\n  */\n  function (effect) {\n    return allowed.toLowerCase().indexOf(effect) !== -1;\n  });\n}\n/**\n * @param {?} parentElement\n * @param {?} childElement\n * @return {?}\n */\n\n\nfunction getDirectChildElement(parentElement, childElement) {\n  /** @type {?} */\n  var directChild = childElement;\n\n  while (directChild.parentNode !== parentElement) {\n    // reached root node without finding given parent\n    if (!directChild.parentNode) {\n      return null;\n    }\n\n    directChild = directChild.parentNode;\n  }\n\n  return (\n    /** @type {?} */\n    directChild\n  );\n}\n/**\n * @param {?} event\n * @param {?} element\n * @param {?} horizontal\n * @return {?}\n */\n\n\nfunction shouldPositionPlaceholderBeforeElement(event, element, horizontal) {\n  /** @type {?} */\n  var bounds = element.getBoundingClientRect(); // If the pointer is in the upper half of the list item element,\n  // we position the placeholder before the list item, otherwise after it.\n\n  if (horizontal) {\n    return event.clientX < bounds.left + bounds.width / 2;\n  }\n\n  return event.clientY < bounds.top + bounds.height / 2;\n}\n/**\n * @param {?} event\n * @param {?} dragImage\n * @return {?}\n */\n\n\nfunction calculateDragImageOffset(event, dragImage) {\n  /** @type {?} */\n  var dragImageComputedStyle = window.getComputedStyle(dragImage);\n  /** @type {?} */\n\n  var paddingTop = parseFloat(dragImageComputedStyle.paddingTop) || 0;\n  /** @type {?} */\n\n  var paddingLeft = parseFloat(dragImageComputedStyle.paddingLeft) || 0;\n  /** @type {?} */\n\n  var borderTop = parseFloat(dragImageComputedStyle.borderTopWidth) || 0;\n  /** @type {?} */\n\n  var borderLeft = parseFloat(dragImageComputedStyle.borderLeftWidth) || 0;\n  return {\n    x: event.offsetX + paddingLeft + borderLeft,\n    y: event.offsetY + paddingTop + borderTop\n  };\n}\n/**\n * @param {?} event\n * @param {?} dragImage\n * @param {?} offsetFunction\n * @return {?}\n */\n\n\nfunction setDragImage(event, dragImage, offsetFunction) {\n  /** @type {?} */\n  var offset = offsetFunction(event, dragImage) || {\n    x: 0,\n    y: 0\n  };\n\n  /** @type {?} */\n  event.dataTransfer.setDragImage(dragImage, offset.x, offset.y);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar _dndState = {\n  isDragging: false,\n  dropEffect: \"none\",\n  effectAllowed: \"all\",\n  type: undefined\n};\n/**\n * @param {?} event\n * @param {?} effectAllowed\n * @param {?} type\n * @return {?}\n */\n\nfunction startDrag(event, effectAllowed, type) {\n  _dndState.isDragging = true;\n  _dndState.dropEffect = \"none\";\n  _dndState.effectAllowed = effectAllowed;\n  _dndState.type = type;\n  event.dataTransfer.effectAllowed = effectAllowed;\n}\n/**\n * @return {?}\n */\n\n\nfunction endDrag() {\n  _dndState.isDragging = false;\n  _dndState.dropEffect = undefined;\n  _dndState.effectAllowed = undefined;\n  _dndState.type = undefined;\n}\n/**\n * @param {?} event\n * @param {?} dropEffect\n * @return {?}\n */\n\n\nfunction setDropEffect(event, dropEffect) {\n  if (_dndState.isDragging === true) {\n    _dndState.dropEffect = dropEffect;\n  }\n\n  event.dataTransfer.dropEffect = dropEffect;\n}\n/**\n * @param {?} event\n * @param {?=} effectAllowed\n * @return {?}\n */\n\n\nfunction getDropEffect(event, effectAllowed) {\n  /** @type {?} */\n  var dataTransferEffectAllowed = event.dataTransfer ?\n  /** @type {?} */\n  event.dataTransfer.effectAllowed : \"uninitialized\";\n  /** @type {?} */\n\n  var effects = filterEffects(DROP_EFFECTS, dataTransferEffectAllowed);\n\n  if (_dndState.isDragging === true) {\n    effects = filterEffects(effects, _dndState.effectAllowed);\n  }\n\n  if (effectAllowed) {\n    effects = filterEffects(effects, effectAllowed);\n  } // MacOS automatically filters dataTransfer.effectAllowed depending on the modifier keys,\n  // therefore the following modifier keys will only affect other operating systems.\n\n\n  if (effects.length === 0) {\n    return \"none\";\n  }\n\n  if (event.ctrlKey && effects.indexOf(\"copy\") !== -1) {\n    return \"copy\";\n  }\n\n  if (event.altKey && effects.indexOf(\"link\") !== -1) {\n    return \"link\";\n  }\n\n  return (\n    /** @type {?} */\n    effects[0]\n  );\n}\n/**\n * @param {?} event\n * @return {?}\n */\n\n\nfunction getDndType(event) {\n  if (_dndState.isDragging === true) {\n    return _dndState.type;\n  }\n  /** @type {?} */\n\n\n  var mimeType = getWellKnownMimeType(event);\n\n  if (mimeType === null) {\n    return undefined;\n  }\n\n  if (mimeType === MSIE_MIME_TYPE || mimeType === JSON_MIME_TYPE) {\n    return undefined;\n  }\n\n  return mimeType.substr(CUSTOM_MIME_TYPE.length + 1) || undefined;\n}\n/**\n * @return {?}\n */\n\n\nfunction isExternalDrag() {\n  return _dndState.isDragging === false;\n}\n/** @type {?} */\n\n\nvar dndState =\n/** @type {?} */\n_dndState;\n\nvar DndDragImageRefDirective = /*@__PURE__*/function () {\n  var DndDragImageRefDirective =\n  /**\n   * @param {?} parent\n   * @param {?} elementRef\n   */\n  function DndDragImageRefDirective(parent, elementRef) {\n    _classCallCheck(this, DndDragImageRefDirective);\n\n    parent.registerDragImage(elementRef);\n  };\n\n  DndDragImageRefDirective.ɵfac = function DndDragImageRefDirective_Factory(t) {\n    return new (t || DndDragImageRefDirective)(ɵngcc0.ɵɵdirectiveInject(DndDraggableDirective), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  DndDragImageRefDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DndDragImageRefDirective,\n    selectors: [[\"\", \"dndDragImageRef\", \"\"]]\n  });\n  return DndDragImageRefDirective;\n}();\n\nvar DndDraggableDirective = /*@__PURE__*/function () {\n  var DndDraggableDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} elementRef\n     * @param {?} renderer\n     * @param {?} ngZone\n     */\n    function DndDraggableDirective(elementRef, renderer, ngZone) {\n      var _this = this;\n\n      _classCallCheck(this, DndDraggableDirective);\n\n      this.elementRef = elementRef;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.dndEffectAllowed = \"copy\";\n      this.dndDraggingClass = \"dndDragging\";\n      this.dndDraggingSourceClass = \"dndDraggingSource\";\n      this.dndDraggableDisabledClass = \"dndDraggableDisabled\";\n      this.dndDragImageOffsetFunction = calculateDragImageOffset;\n      this.dndStart = new EventEmitter();\n      this.dndDrag = new EventEmitter();\n      this.dndEnd = new EventEmitter();\n      this.dndMoved = new EventEmitter();\n      this.dndCopied = new EventEmitter();\n      this.dndLinked = new EventEmitter();\n      this.dndCanceled = new EventEmitter();\n      this.draggable = true;\n      this.isDragStarted = false;\n\n      this.dragEventHandler =\n      /**\n      * @param {?} event\n      * @return {?}\n      */\n      function (event) {\n        return _this.onDrag(event);\n      };\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    _createClass(DndDraggableDirective, [{\n      key: \"dndDisableIf\",\n      set: function set(value) {\n        this.draggable = !value;\n\n        if (this.draggable) {\n          this.renderer.removeClass(this.elementRef.nativeElement, this.dndDraggableDisabledClass);\n        } else {\n          this.renderer.addClass(this.elementRef.nativeElement, this.dndDraggableDisabledClass);\n        }\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"dndDisableDragIf\",\n      set: function set(value) {\n        this.dndDisableIf = value;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        var _this2 = this;\n\n        this.ngZone.runOutsideAngular(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this2.elementRef.nativeElement.addEventListener(\"drag\", _this2.dragEventHandler);\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.elementRef.nativeElement.removeEventListener(\"drag\", this.dragEventHandler);\n\n        if (this.isDragStarted === true) {\n          endDrag();\n        }\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onDragStart\",\n      value: function onDragStart(event) {\n        var _this3 = this;\n\n        if (this.draggable === false) {\n          return false;\n        } // check if there is dnd handle and if the dnd handle was used to start the drag\n\n\n        if (typeof this.dndHandle !== \"undefined\" && typeof event._dndUsingHandle === \"undefined\") {\n          return false;\n        } // initialize global state\n\n\n        startDrag(event, this.dndEffectAllowed, this.dndType);\n        this.isDragStarted = true;\n        setDragData(event, {\n          data: this.dndDraggable,\n          type: this.dndType\n        }, dndState.effectAllowed);\n        this.dragImage = this.determineDragImage(); // set dragging css class prior to setDragImage so styles are applied before\n        // TODO breaking change: add class to elementRef rather than drag image which could be another element\n\n        this.renderer.addClass(this.dragImage, this.dndDraggingClass); // set custom dragimage if present\n        // set dragimage if drag is started from dndHandle\n\n        if (typeof this.dndDragImageElementRef !== \"undefined\" || typeof event._dndUsingHandle !== \"undefined\") {\n          setDragImage(event, this.dragImage, this.dndDragImageOffsetFunction);\n        } // add dragging source css class on first drag event\n\n        /** @type {?} */\n\n\n        var unregister = this.renderer.listen(this.elementRef.nativeElement, \"drag\",\n        /**\n        * @return {?}\n        */\n        function () {\n          _this3.renderer.addClass(_this3.elementRef.nativeElement, _this3.dndDraggingSourceClass);\n\n          unregister();\n        });\n        this.dndStart.emit(event);\n        event.stopPropagation();\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onDrag\",\n      value: function onDrag(event) {\n        this.dndDrag.emit(event);\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onDragEnd\",\n      value: function onDragEnd(event) {\n        var _this4 = this;\n\n        // get drop effect from custom stored state as its not reliable across browsers\n\n        /** @type {?} */\n        var dropEffect = dndState.dropEffect;\n        /** @type {?} */\n\n        var dropEffectEmitter;\n\n        switch (dropEffect) {\n          case \"copy\":\n            dropEffectEmitter = this.dndCopied;\n            break;\n\n          case \"link\":\n            dropEffectEmitter = this.dndLinked;\n            break;\n\n          case \"move\":\n            dropEffectEmitter = this.dndMoved;\n            break;\n\n          default:\n            dropEffectEmitter = this.dndCanceled;\n            break;\n        }\n\n        dropEffectEmitter.emit(event);\n        this.dndEnd.emit(event); // reset global state\n\n        endDrag();\n        this.isDragStarted = false;\n        this.renderer.removeClass(this.dragImage, this.dndDraggingClass); // IE9 special hammering\n\n        window.setTimeout(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this4.renderer.removeClass(_this4.elementRef.nativeElement, _this4.dndDraggingSourceClass);\n        }, 0);\n        event.stopPropagation();\n      }\n      /**\n       * @param {?} handle\n       * @return {?}\n       */\n\n    }, {\n      key: \"registerDragHandle\",\n      value: function registerDragHandle(handle) {\n        this.dndHandle = handle;\n      }\n      /**\n       * @param {?} elementRef\n       * @return {?}\n       */\n\n    }, {\n      key: \"registerDragImage\",\n      value: function registerDragImage(elementRef) {\n        this.dndDragImageElementRef = elementRef;\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"determineDragImage\",\n      value: function determineDragImage() {\n        // evaluate custom drag image existence\n        if (typeof this.dndDragImageElementRef !== \"undefined\") {\n          return (\n            /** @type {?} */\n            this.dndDragImageElementRef.nativeElement\n          );\n        } else {\n          return this.elementRef.nativeElement;\n        }\n      }\n    }]);\n\n    return DndDraggableDirective;\n  }();\n\n  DndDraggableDirective.ɵfac = function DndDraggableDirective_Factory(t) {\n    return new (t || DndDraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  DndDraggableDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DndDraggableDirective,\n    selectors: [[\"\", \"dndDraggable\", \"\"]],\n    hostVars: 1,\n    hostBindings: function DndDraggableDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"dragstart\", function DndDraggableDirective_dragstart_HostBindingHandler($event) {\n          return ctx.onDragStart($event);\n        })(\"dragend\", function DndDraggableDirective_dragend_HostBindingHandler($event) {\n          return ctx.onDragEnd($event);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"draggable\", ctx.draggable);\n      }\n    },\n    inputs: {\n      dndEffectAllowed: \"dndEffectAllowed\",\n      dndDraggingClass: \"dndDraggingClass\",\n      dndDraggingSourceClass: \"dndDraggingSourceClass\",\n      dndDraggableDisabledClass: \"dndDraggableDisabledClass\",\n      dndDragImageOffsetFunction: \"dndDragImageOffsetFunction\",\n      dndDisableIf: \"dndDisableIf\",\n      dndDisableDragIf: \"dndDisableDragIf\",\n      dndDraggable: \"dndDraggable\",\n      dndType: \"dndType\"\n    },\n    outputs: {\n      dndStart: \"dndStart\",\n      dndDrag: \"dndDrag\",\n      dndEnd: \"dndEnd\",\n      dndMoved: \"dndMoved\",\n      dndCopied: \"dndCopied\",\n      dndLinked: \"dndLinked\",\n      dndCanceled: \"dndCanceled\"\n    }\n  });\n  return DndDraggableDirective;\n}();\n\nvar DndPlaceholderRefDirective = /*@__PURE__*/function () {\n  var DndPlaceholderRefDirective =\n  /**\n   * @param {?} elementRef\n   */\n  function DndPlaceholderRefDirective(elementRef) {\n    _classCallCheck(this, DndPlaceholderRefDirective);\n\n    this.elementRef = elementRef;\n  };\n\n  DndPlaceholderRefDirective.ɵfac = function DndPlaceholderRefDirective_Factory(t) {\n    return new (t || DndPlaceholderRefDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  DndPlaceholderRefDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DndPlaceholderRefDirective,\n    selectors: [[\"\", \"dndPlaceholderRef\", \"\"]]\n  });\n  return DndPlaceholderRefDirective;\n}();\n\nvar DndDropzoneDirective = /*@__PURE__*/function () {\n  var DndDropzoneDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} ngZone\n     * @param {?} elementRef\n     * @param {?} renderer\n     */\n    function DndDropzoneDirective(ngZone, elementRef, renderer) {\n      var _this5 = this;\n\n      _classCallCheck(this, DndDropzoneDirective);\n\n      this.ngZone = ngZone;\n      this.elementRef = elementRef;\n      this.renderer = renderer;\n      this.dndAllowExternal = false;\n      this.dndHorizontal = false;\n      this.dndDragoverClass = \"dndDragover\";\n      this.dndDropzoneDisabledClass = \"dndDropzoneDisabled\";\n      this.dndDragover = new EventEmitter();\n      this.dndDrop = new EventEmitter();\n      this.placeholder = null;\n      this.disabled = false;\n\n      this.dragEnterEventHandler =\n      /**\n      * @param {?} event\n      * @return {?}\n      */\n      function (event) {\n        return _this5.onDragEnter(event);\n      };\n\n      this.dragOverEventHandler =\n      /**\n      * @param {?} event\n      * @return {?}\n      */\n      function (event) {\n        return _this5.onDragOver(event);\n      };\n\n      this.dragLeaveEventHandler =\n      /**\n      * @param {?} event\n      * @return {?}\n      */\n      function (event) {\n        return _this5.onDragLeave(event);\n      };\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    _createClass(DndDropzoneDirective, [{\n      key: \"dndDisableIf\",\n      set: function set(value) {\n        this.disabled = !!value;\n\n        if (this.disabled) {\n          this.renderer.addClass(this.elementRef.nativeElement, this.dndDropzoneDisabledClass);\n        } else {\n          this.renderer.removeClass(this.elementRef.nativeElement, this.dndDropzoneDisabledClass);\n        }\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"dndDisableDropIf\",\n      set: function set(value) {\n        this.dndDisableIf = value;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        var _this6 = this;\n\n        this.placeholder = this.tryGetPlaceholder();\n        this.removePlaceholderFromDOM();\n        this.ngZone.runOutsideAngular(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this6.elementRef.nativeElement.addEventListener(\"dragenter\", _this6.dragEnterEventHandler);\n\n          _this6.elementRef.nativeElement.addEventListener(\"dragover\", _this6.dragOverEventHandler);\n\n          _this6.elementRef.nativeElement.addEventListener(\"dragleave\", _this6.dragLeaveEventHandler);\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.elementRef.nativeElement.removeEventListener(\"dragenter\", this.dragEnterEventHandler);\n        this.elementRef.nativeElement.removeEventListener(\"dragover\", this.dragOverEventHandler);\n        this.elementRef.nativeElement.removeEventListener(\"dragleave\", this.dragLeaveEventHandler);\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onDragEnter\",\n      value: function onDragEnter(event) {\n        // check if another dropzone is activated\n        if (event._dndDropzoneActive === true) {\n          this.cleanupDragoverState();\n          return;\n        } // set as active if the target element is inside this dropzone\n\n\n        if (typeof event._dndDropzoneActive === \"undefined\") {\n          /** @type {?} */\n          var newTarget = document.elementFromPoint(event.clientX, event.clientY);\n\n          if (this.elementRef.nativeElement.contains(newTarget)) {\n            event._dndDropzoneActive = true;\n          }\n        } // check if this drag event is allowed to drop on this dropzone\n\n        /** @type {?} */\n\n\n        var type = getDndType(event);\n\n        if (this.isDropAllowed(type) === false) {\n          return;\n        } // allow the dragenter\n\n\n        event.preventDefault();\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onDragOver\",\n      value: function onDragOver(event) {\n        // With nested dropzones, we want to ignore this event if a child dropzone\n        // has already handled a dragover.  Historically, event.stopPropagation() was\n        // used to prevent this bubbling, but that prevents any dragovers outside the\n        // ngx-drag-drop component, and stops other use cases such as scrolling on drag.\n        // Instead, we can check if the event was already prevented by a child and bail early.\n        if (event.defaultPrevented) {\n          return;\n        } // check if this drag event is allowed to drop on this dropzone\n\n        /** @type {?} */\n\n\n        var type = getDndType(event);\n\n        if (this.isDropAllowed(type) === false) {\n          return;\n        }\n\n        this.checkAndUpdatePlaceholderPosition(event);\n        /** @type {?} */\n\n        var dropEffect = getDropEffect(event, this.dndEffectAllowed);\n\n        if (dropEffect === \"none\") {\n          this.cleanupDragoverState();\n          return;\n        } // allow the dragover\n\n\n        event.preventDefault(); // set the drop effect\n\n        setDropEffect(event, dropEffect);\n        this.dndDragover.emit(event);\n        this.renderer.addClass(this.elementRef.nativeElement, this.dndDragoverClass);\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onDrop\",\n      value: function onDrop(event) {\n        try {\n          // check if this drag event is allowed to drop on this dropzone\n\n          /** @type {?} */\n          var type = getDndType(event);\n\n          if (this.isDropAllowed(type) === false) {\n            return;\n          }\n          /** @type {?} */\n\n\n          var data = getDropData(event, isExternalDrag());\n\n          if (this.isDropAllowed(data.type) === false) {\n            return;\n          } // signal custom drop handling\n\n\n          event.preventDefault();\n          /** @type {?} */\n\n          var dropEffect = getDropEffect(event);\n          setDropEffect(event, dropEffect);\n\n          if (dropEffect === \"none\") {\n            return;\n          }\n          /** @type {?} */\n\n\n          var dropIndex = this.getPlaceholderIndex(); // if for whatever reason the placeholder is not present in the DOM but it should be there\n          // we don't allow/emit the drop event since it breaks the contract\n          // seems to only happen if drag and drop is executed faster than the DOM updates\n\n          if (dropIndex === -1) {\n            return;\n          }\n\n          this.dndDrop.emit({\n            event: event,\n            dropEffect: dropEffect,\n            isExternal: isExternalDrag(),\n            data: data.data,\n            index: dropIndex,\n            type: type\n          });\n          event.stopPropagation();\n        } finally {\n          this.cleanupDragoverState();\n        }\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onDragLeave\",\n      value: function onDragLeave(event) {\n        // check if still inside this dropzone and not yet handled by another dropzone\n        if (typeof event._dndDropzoneActive === \"undefined\") {\n          /** @type {?} */\n          var newTarget = document.elementFromPoint(event.clientX, event.clientY);\n\n          if (this.elementRef.nativeElement.contains(newTarget)) {\n            event._dndDropzoneActive = true;\n            return;\n          }\n        }\n\n        this.cleanupDragoverState(); // cleanup drop effect when leaving dropzone\n\n        setDropEffect(event, \"none\");\n      }\n      /**\n       * @private\n       * @param {?=} type\n       * @return {?}\n       */\n\n    }, {\n      key: \"isDropAllowed\",\n      value: function isDropAllowed(type) {\n        // dropzone is disabled -> deny it\n        if (this.disabled === true) {\n          return false;\n        } // if drag did not start from our directive\n        // and external drag sources are not allowed -> deny it\n\n\n        if (isExternalDrag() === true && this.dndAllowExternal === false) {\n          return false;\n        } // no filtering by types -> allow it\n\n\n        if (!this.dndDropzone) {\n          return true;\n        } // no type set -> allow it\n\n\n        if (!type) {\n          return true;\n        }\n\n        if (Array.isArray(this.dndDropzone) === false) {\n          throw new Error(\"dndDropzone: bound value to [dndDropzone] must be an array!\");\n        } // if dropzone contains type -> allow it\n\n\n        return this.dndDropzone.indexOf(type) !== -1;\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"tryGetPlaceholder\",\n      value: function tryGetPlaceholder() {\n        if (typeof this.dndPlaceholderRef !== \"undefined\") {\n          return (\n            /** @type {?} */\n            this.dndPlaceholderRef.elementRef.nativeElement\n          );\n        } // TODO nasty workaround needed because if ng-container / template is used @ContentChild() or DI will fail because\n        // of wrong context see angular bug https://github.com/angular/angular/issues/13517\n\n\n        return this.elementRef.nativeElement.querySelector(\"[dndPlaceholderRef]\");\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"removePlaceholderFromDOM\",\n      value: function removePlaceholderFromDOM() {\n        if (this.placeholder !== null && this.placeholder.parentNode !== null) {\n          this.placeholder.parentNode.removeChild(this.placeholder);\n        }\n      }\n      /**\n       * @private\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"checkAndUpdatePlaceholderPosition\",\n      value: function checkAndUpdatePlaceholderPosition(event) {\n        if (this.placeholder === null) {\n          return;\n        } // make sure the placeholder is in the DOM\n\n\n        if (this.placeholder.parentNode !== this.elementRef.nativeElement) {\n          this.renderer.appendChild(this.elementRef.nativeElement, this.placeholder);\n        } // update the position if the event originates from a child element of the dropzone\n\n        /** @type {?} */\n\n\n        var directChild = getDirectChildElement(this.elementRef.nativeElement,\n        /** @type {?} */\n        event.target); // early exit if no direct child or direct child is placeholder\n\n        if (directChild === null || directChild === this.placeholder) {\n          return;\n        }\n        /** @type {?} */\n\n\n        var positionPlaceholderBeforeDirectChild = shouldPositionPlaceholderBeforeElement(event, directChild, this.dndHorizontal);\n\n        if (positionPlaceholderBeforeDirectChild) {\n          // do insert before only if necessary\n          if (directChild.previousSibling !== this.placeholder) {\n            this.renderer.insertBefore(this.elementRef.nativeElement, this.placeholder, directChild);\n          }\n        } else {\n          // do insert after only if necessary\n          if (directChild.nextSibling !== this.placeholder) {\n            this.renderer.insertBefore(this.elementRef.nativeElement, this.placeholder, directChild.nextSibling);\n          }\n        }\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"getPlaceholderIndex\",\n      value: function getPlaceholderIndex() {\n        if (this.placeholder === null) {\n          return undefined;\n        }\n        /** @type {?} */\n\n\n        var element =\n        /** @type {?} */\n        this.elementRef.nativeElement;\n        return Array.prototype.indexOf.call(element.children, this.placeholder);\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"cleanupDragoverState\",\n      value: function cleanupDragoverState() {\n        this.renderer.removeClass(this.elementRef.nativeElement, this.dndDragoverClass);\n        this.removePlaceholderFromDOM();\n      }\n    }]);\n\n    return DndDropzoneDirective;\n  }();\n\n  DndDropzoneDirective.ɵfac = function DndDropzoneDirective_Factory(t) {\n    return new (t || DndDropzoneDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  DndDropzoneDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DndDropzoneDirective,\n    selectors: [[\"\", \"dndDropzone\", \"\"]],\n    contentQueries: function DndDropzoneDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, DndPlaceholderRefDirective, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dndPlaceholderRef = _t.first);\n      }\n    },\n    hostBindings: function DndDropzoneDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"drop\", function DndDropzoneDirective_drop_HostBindingHandler($event) {\n          return ctx.onDrop($event);\n        });\n      }\n    },\n    inputs: {\n      dndAllowExternal: \"dndAllowExternal\",\n      dndHorizontal: \"dndHorizontal\",\n      dndDragoverClass: \"dndDragoverClass\",\n      dndDropzoneDisabledClass: \"dndDropzoneDisabledClass\",\n      dndDisableIf: \"dndDisableIf\",\n      dndDisableDropIf: \"dndDisableDropIf\",\n      dndDropzone: \"dndDropzone\",\n      dndEffectAllowed: \"dndEffectAllowed\"\n    },\n    outputs: {\n      dndDragover: \"dndDragover\",\n      dndDrop: \"dndDrop\"\n    }\n  });\n  return DndDropzoneDirective;\n}();\n\nvar DndHandleDirective = /*@__PURE__*/function () {\n  var DndHandleDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} parent\n     */\n    function DndHandleDirective(parent) {\n      _classCallCheck(this, DndHandleDirective);\n\n      this.draggable = true;\n      parent.registerDragHandle(this);\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    _createClass(DndHandleDirective, [{\n      key: \"onDragEvent\",\n      value: function onDragEvent(event) {\n        event._dndUsingHandle = true;\n      }\n    }]);\n\n    return DndHandleDirective;\n  }();\n\n  DndHandleDirective.ɵfac = function DndHandleDirective_Factory(t) {\n    return new (t || DndHandleDirective)(ɵngcc0.ɵɵdirectiveInject(DndDraggableDirective));\n  };\n\n  DndHandleDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DndHandleDirective,\n    selectors: [[\"\", \"dndHandle\", \"\"]],\n    hostVars: 1,\n    hostBindings: function DndHandleDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"dragstart\", function DndHandleDirective_dragstart_HostBindingHandler($event) {\n          return ctx.onDragEvent($event);\n        })(\"dragend\", function DndHandleDirective_dragend_HostBindingHandler($event) {\n          return ctx.onDragEvent($event);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"draggable\", ctx.draggable);\n      }\n    }\n  });\n  return DndHandleDirective;\n}();\n\nvar DndModule = /*@__PURE__*/function () {\n  var DndModule = function DndModule() {\n    _classCallCheck(this, DndModule);\n  };\n\n  DndModule.ɵfac = function DndModule_Factory(t) {\n    return new (t || DndModule)();\n  };\n\n  DndModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: DndModule\n  });\n  DndModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return DndModule;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DndModule, {\n    declarations: function declarations() {\n      return [DndDraggableDirective, DndDropzoneDirective, DndHandleDirective, DndPlaceholderRefDirective, DndDragImageRefDirective];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [DndDraggableDirective, DndDropzoneDirective, DndHandleDirective, DndPlaceholderRefDirective, DndDragImageRefDirective];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { DndDragImageRefDirective, DndDraggableDirective, DndPlaceholderRefDirective, DndDropzoneDirective, DndHandleDirective, DndModule }; //# sourceMappingURL=ngx-drag-drop.js.map","map":null,"metadata":{},"sourceType":"module"}