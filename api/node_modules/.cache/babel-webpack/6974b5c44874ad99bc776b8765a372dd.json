{"ast":null,"code":"/*\r\n * HTML5 Parser By Sam Blowes\r\n *\r\n * Designed for HTML5 documents\r\n *\r\n * Original code by John Resig (ejohn.org)\r\n * http://ejohn.org/blog/pure-javascript-html-parser/\r\n * Original code by Erik Arvidsson, Mozilla Public License\r\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\r\n *\r\n * ----------------------------------------------------------------------------\r\n * License\r\n * ----------------------------------------------------------------------------\r\n *\r\n * This code is triple licensed using Apache Software License 2.0,\r\n * Mozilla Public License or GNU Public License\r\n * \r\n * ////////////////////////////////////////////////////////////////////////////\r\n * \r\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\r\n * use this file except in compliance with the License.  You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n * \r\n * ////////////////////////////////////////////////////////////////////////////\r\n * \r\n * The contents of this file are subject to the Mozilla Public License\r\n * Version 1.1 (the \"License\"); you may not use this file except in\r\n * compliance with the License. You may obtain a copy of the License at\r\n * http://www.mozilla.org/MPL/\r\n * \r\n * Software distributed under the License is distributed on an \"AS IS\"\r\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing rights and limitations\r\n * under the License.\r\n * \r\n * The Original Code is Simple HTML Parser.\r\n * \r\n * The Initial Developer of the Original Code is Erik Arvidsson.\r\n * Portions created by Erik Arvidssson are Copyright (C) 2004. All Rights\r\n * Reserved.\r\n * \r\n * ////////////////////////////////////////////////////////////////////////////\r\n * \r\n * This program is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU General Public License\r\n * as published by the Free Software Foundation; either version 2\r\n * of the License, or (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\r\n *\r\n * ----------------------------------------------------------------------------\r\n * Usage\r\n * ----------------------------------------------------------------------------\r\n *\r\n * // Use like so:\r\n * HTMLParser(htmlString, {\r\n *     start: function(tag, attrs, unary) {},\r\n *     end: function(tag) {},\r\n *     chars: function(text) {},\r\n *     comment: function(text) {}\r\n * });\r\n *\r\n * // or to get an XML string:\r\n * HTMLtoXML(htmlString);\r\n *\r\n * // or to get an XML DOM Document\r\n * HTMLtoDOM(htmlString);\r\n *\r\n * // or to inject into an existing document/DOM node\r\n * HTMLtoDOM(htmlString, document);\r\n * HTMLtoDOM(htmlString, document.body);\r\n *\r\n */\n(function () {\n  // Regular Expressions for parsing tags and attributes\n  var startTag = /^<([-A-Za-z0-9_]+)((?:\\s+[a-zA-Z_:][-a-zA-Z0-9_:.]*(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/,\n      endTag = /^<\\/([-A-Za-z0-9_]+)[^>]*>/,\n      attr = /([a-zA-Z_:][-a-zA-Z0-9_:.]*)(?:\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|([^>\\s]+)))?/g; // Empty Elements - HTML 5\n\n  var empty = makeMap(\"area,base,basefont,br,col,frame,hr,img,input,link,meta,param,embed,command,keygen,source,track,wbr\"); // Block Elements - HTML 5\n\n  var block = makeMap(\"a,address,article,applet,aside,audio,blockquote,button,canvas,center,dd,del,dir,div,dl,dt,fieldset,figcaption,figure,footer,form,frameset,h1,h2,h3,h4,h5,h6,header,hgroup,hr,iframe,ins,isindex,li,map,menu,noframes,noscript,object,ol,output,p,pre,section,script,table,tbody,td,tfoot,th,thead,tr,ul,video\"); // Inline Elements - HTML 5\n\n  var inline = makeMap(\"abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,textarea,tt,u,var\"); // Elements that you can, intentionally, leave open\n  // (and which close themselves)\n\n  var closeSelf = makeMap(\"colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr\"); // Attributes that have their values filled in disabled=\"disabled\"\n\n  var fillAttrs = makeMap(\"checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected\"); // Special Elements (can contain anything)\n\n  var special = makeMap(\"script,style\");\n\n  var HTMLParser = this.HTMLParser = function (html, handler) {\n    var index,\n        chars,\n        match,\n        stack = [],\n        last = html;\n\n    stack.last = function () {\n      return this[this.length - 1];\n    };\n\n    while (html) {\n      chars = true; // Make sure we're not in a script or style element\n\n      if (!stack.last() || !special[stack.last()]) {\n        // Comment\n        if (html.indexOf(\"<!--\") == 0) {\n          index = html.indexOf(\"-->\");\n\n          if (index >= 0) {\n            if (handler.comment) handler.comment(html.substring(4, index));\n            html = html.substring(index + 3);\n            chars = false;\n          } // end tag\n\n        } else if (html.indexOf(\"</\") == 0) {\n          match = html.match(endTag);\n\n          if (match) {\n            html = html.substring(match[0].length);\n            match[0].replace(endTag, parseEndTag);\n            chars = false;\n          } // start tag\n\n        } else if (html.indexOf(\"<\") == 0) {\n          match = html.match(startTag);\n\n          if (match) {\n            html = html.substring(match[0].length);\n            match[0].replace(startTag, parseStartTag);\n            chars = false;\n          }\n        }\n\n        if (chars) {\n          index = html.indexOf(\"<\");\n          var text = index < 0 ? html : html.substring(0, index);\n          html = index < 0 ? \"\" : html.substring(index);\n          if (handler.chars) handler.chars(text);\n        }\n      } else {\n        html = html.replace(new RegExp(\"([\\\\s\\\\S]*?)<\\/\" + stack.last() + \"[^>]*>\"), function (all, text) {\n          text = text.replace(/<!--([\\s\\S]*?)-->|<!\\[CDATA\\[([\\s\\S]*?)]]>/g, \"$1$2\");\n          if (handler.chars) handler.chars(text);\n          return \"\";\n        });\n        parseEndTag(\"\", stack.last());\n      }\n\n      if (html == last) throw \"Parse Error: \" + html;\n      last = html;\n    } // Clean up any remaining tags\n\n\n    parseEndTag();\n\n    function parseStartTag(tag, tagName, rest, unary) {\n      tagName = tagName.toLowerCase();\n\n      if (block[tagName]) {\n        while (stack.last() && inline[stack.last()]) {\n          parseEndTag(\"\", stack.last());\n        }\n      }\n\n      if (closeSelf[tagName] && stack.last() == tagName) {\n        parseEndTag(\"\", tagName);\n      }\n\n      unary = empty[tagName] || !!unary;\n      if (!unary) stack.push(tagName);\n\n      if (handler.start) {\n        var attrs = [];\n        rest.replace(attr, function (match, name) {\n          var value = arguments[2] ? arguments[2] : arguments[3] ? arguments[3] : arguments[4] ? arguments[4] : fillAttrs[name] ? name : \"\";\n          attrs.push({\n            name: name,\n            value: value,\n            escaped: value.replace(/(^|[^\\\\])\"/g, '$1\\\\\\\"') //\"\n\n          });\n        });\n        if (handler.start) handler.start(tagName, attrs, unary);\n      }\n    }\n\n    function parseEndTag(tag, tagName) {\n      // If no tag name is provided, clean shop\n      if (!tagName) var pos = 0; // Find the closest opened tag of the same type\n      else for (var pos = stack.length - 1; pos >= 0; pos--) {\n          if (stack[pos] == tagName) break;\n        }\n\n      if (pos >= 0) {\n        // Close all the open elements, up the stack\n        for (var i = stack.length - 1; i >= pos; i--) {\n          if (handler.end) handler.end(stack[i]);\n        } // Remove the open elements from the stack\n\n\n        stack.length = pos;\n      }\n    }\n  };\n\n  this.HTMLtoXML = function (html) {\n    var results = \"\";\n    HTMLParser(html, {\n      start: function start(tag, attrs, unary) {\n        results += \"<\" + tag;\n\n        for (var i = 0; i < attrs.length; i++) {\n          results += \" \" + attrs[i].name + '=\"' + attrs[i].escaped + '\"';\n        }\n\n        results += \">\";\n      },\n      end: function end(tag) {\n        results += \"</\" + tag + \">\";\n      },\n      chars: function chars(text) {\n        results += text;\n      },\n      comment: function comment(text) {\n        results += \"<!--\" + text + \"-->\";\n      }\n    });\n    return results;\n  };\n\n  this.HTMLtoDOM = function (html, doc) {\n    // There can be only one of these elements\n    var one = makeMap(\"html,head,body,title\"); // Enforce a structure for the document\n\n    var structure = {\n      link: \"head\",\n      base: \"head\"\n    };\n\n    if (!doc) {\n      if (typeof DOMDocument != \"undefined\") doc = new DOMDocument();else if (typeof document != \"undefined\" && document.implementation && document.implementation.createDocument) doc = document.implementation.createDocument(\"\", \"\", null);else if (typeof ActiveX != \"undefined\") doc = new ActiveXObject(\"Msxml.DOMDocument\");\n    } else doc = doc.ownerDocument || doc.getOwnerDocument && doc.getOwnerDocument() || doc;\n\n    var elems = [],\n        documentElement = doc.documentElement || doc.getDocumentElement && doc.getDocumentElement(); // If we're dealing with an empty document then we\n    // need to pre-populate it with the HTML document structure\n\n    if (!documentElement && doc.createElement) (function () {\n      var html = doc.createElement(\"html\");\n      var head = doc.createElement(\"head\");\n      head.appendChild(doc.createElement(\"title\"));\n      html.appendChild(head);\n      html.appendChild(doc.createElement(\"body\"));\n      doc.appendChild(html);\n    })(); // Find all the unique elements\n\n    if (doc.getElementsByTagName) for (var i in one) {\n      one[i] = doc.getElementsByTagName(i)[0];\n    } // If we're working with a document, inject contents into\n    // the body element\n\n    var curParentNode = one.body;\n    HTMLParser(html, {\n      start: function start(tagName, attrs, unary) {\n        // If it's a pre-built element, then we can ignore\n        // its construction\n        if (one[tagName]) {\n          curParentNode = one[tagName];\n\n          if (!unary) {\n            elems.push(curParentNode);\n          }\n\n          return;\n        }\n\n        var elem = doc.createElement(tagName);\n\n        for (var attr in attrs) {\n          elem.setAttribute(attrs[attr].name, attrs[attr].value);\n        }\n\n        if (structure[tagName] && typeof one[structure[tagName]] != \"boolean\") one[structure[tagName]].appendChild(elem);else if (curParentNode && curParentNode.appendChild) curParentNode.appendChild(elem);\n\n        if (!unary) {\n          elems.push(elem);\n          curParentNode = elem;\n        }\n      },\n      end: function end(tag) {\n        elems.length -= 1; // Init the new parentNode\n\n        curParentNode = elems[elems.length - 1];\n      },\n      chars: function chars(text) {\n        curParentNode.appendChild(doc.createTextNode(text));\n      },\n      comment: function comment(text) {// create comment node\n      }\n    });\n    return doc;\n  };\n\n  function makeMap(str) {\n    var obj = {},\n        items = str.split(\",\");\n\n    for (var i = 0; i < items.length; i++) {\n      obj[items[i]] = true;\n    }\n\n    return obj;\n  }\n})();","map":null,"metadata":{},"sourceType":"script"}