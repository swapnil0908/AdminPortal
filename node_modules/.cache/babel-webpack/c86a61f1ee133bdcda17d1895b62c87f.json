{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _createClass = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createClass\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n *  This is a base driver provider class.\n *  It is responsible for setting up the account object, tearing\n *  it down, and setting up the driver correctly.\n */\n\nvar q = require(\"q\");\n\nvar selenium_webdriver_1 = require(\"selenium-webdriver\");\n\nvar bpRunner_1 = require(\"../bpRunner\");\n\nvar DriverProvider = /*#__PURE__*/function () {\n  function DriverProvider(config) {\n    _classCallCheck(this, DriverProvider);\n\n    this.config_ = config;\n    this.drivers_ = [];\n    this.bpRunner = new bpRunner_1.BlockingProxyRunner(config);\n  }\n  /**\n   * Get all existing drivers.\n   *\n   * @public\n   * @return array of webdriver instances\n   */\n\n\n  _createClass(DriverProvider, [{\n    key: \"getExistingDrivers\",\n    value: function getExistingDrivers() {\n      return this.drivers_.slice(); // Create a shallow copy\n    }\n  }, {\n    key: \"getBPUrl\",\n    value: function getBPUrl() {\n      if (this.config_.blockingProxyUrl) {\n        return this.config_.blockingProxyUrl;\n      }\n\n      return \"http://localhost:\".concat(this.bpRunner.port);\n    }\n    /**\n     * Create a new driver.\n     *\n     * @public\n     * @return webdriver instance\n     */\n\n  }, {\n    key: \"getNewDriver\",\n    value: function getNewDriver() {\n      var builder;\n\n      if (this.config_.useBlockingProxy) {\n        builder = new selenium_webdriver_1.Builder().usingServer(this.getBPUrl()).withCapabilities(this.config_.capabilities);\n      } else {\n        builder = new selenium_webdriver_1.Builder().usingServer(this.config_.seleniumAddress).usingWebDriverProxy(this.config_.webDriverProxy).withCapabilities(this.config_.capabilities);\n      }\n\n      if (this.config_.disableEnvironmentOverrides === true) {\n        builder.disableEnvironmentOverrides();\n      }\n\n      var newDriver = builder.build();\n      this.drivers_.push(newDriver);\n      return newDriver;\n    }\n    /**\n     * Quit a driver.\n     *\n     * @public\n     * @param webdriver instance\n     */\n\n  }, {\n    key: \"quitDriver\",\n    value: function quitDriver(driver) {\n      var driverIndex = this.drivers_.indexOf(driver);\n\n      if (driverIndex >= 0) {\n        this.drivers_.splice(driverIndex, 1);\n      }\n\n      if (driver.getSession() === undefined) {\n        return selenium_webdriver_1.promise.when(undefined);\n      } else {\n        return driver.getSession().then(function (session_) {\n          if (session_) {\n            return driver.quit();\n          }\n        }).catch(function (err) {});\n      }\n    }\n    /**\n     * Quits an array of drivers and returns a q promise instead of a webdriver one\n     *\n     * @param drivers {webdriver.WebDriver[]} The webdriver instances\n     */\n\n  }, {\n    key: \"updateJob\",\n    value:\n    /**\n     * Default update job method.\n     * @return a promise\n     */\n    function updateJob(update) {\n      return q.fcall(function () {});\n    }\n  }, {\n    key: \"setupEnv\",\n    value:\n    /**\n     * Default setup environment method, common to all driver providers.\n     */\n    function setupEnv() {\n      var _this = this;\n\n      var driverPromise = this.setupDriverEnv();\n\n      if (this.config_.useBlockingProxy && !this.config_.blockingProxyUrl) {\n        // TODO(heathkit): If set, pass the webDriverProxy to BP.\n        return driverPromise.then(function () {\n          return _this.bpRunner.start();\n        });\n      }\n\n      return driverPromise;\n    }\n  }, {\n    key: \"teardownEnv\",\n    value:\n    /**\n     * Teardown and destroy the environment and do any associated cleanup.\n     * Shuts down the drivers.\n     *\n     * @public\n     * @return {q.Promise<any>} A promise which will resolve when the environment is down.\n     */\n    function teardownEnv() {\n      return DriverProvider.quitDrivers(this, this.drivers_);\n    }\n  }], [{\n    key: \"quitDrivers\",\n    value: function quitDrivers(provider, drivers) {\n      var deferred = q.defer();\n      selenium_webdriver_1.promise.all(drivers.map(function (driver) {\n        return provider.quitDriver(driver);\n      })).then(function () {\n        deferred.resolve();\n      }, function () {\n        deferred.resolve();\n      });\n      return deferred.promise;\n    }\n  }]);\n\n  return DriverProvider;\n}();\n\nexports.DriverProvider = DriverProvider; //# sourceMappingURL=driverProvider.js.map","map":null,"metadata":{},"sourceType":"script"}