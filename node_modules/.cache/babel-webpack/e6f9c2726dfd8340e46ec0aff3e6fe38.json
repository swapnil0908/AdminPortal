{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _createClass = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createClass\").default;\n\nvar _inherits = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/inherits\").default;\n\nvar _createSuper = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createSuper\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n *  This is an implementation of the Direct Driver Provider.\n *  It is responsible for setting up the account object, tearing\n *  it down, and setting up the driver correctly.\n */\n\nvar fs = require(\"fs\");\n\nvar path = require(\"path\");\n\nvar q = require(\"q\");\n\nvar selenium_webdriver_1 = require(\"selenium-webdriver\");\n\nvar chrome_1 = require(\"selenium-webdriver/chrome\");\n\nvar exitCodes_1 = require(\"../exitCodes\");\n\nvar logger_1 = require(\"../logger\");\n\nvar driverProvider_1 = require(\"./driverProvider\");\n\nvar SeleniumConfig = require('webdriver-manager/built/lib/config').Config;\n\nvar logger = new logger_1.Logger('direct');\n\nvar Direct = /*#__PURE__*/function (_driverProvider_1$Dri) {\n  _inherits(Direct, _driverProvider_1$Dri);\n\n  var _super = _createSuper(Direct);\n\n  function Direct(config) {\n    _classCallCheck(this, Direct);\n\n    return _super.call(this, config);\n  }\n  /**\n   * Configure and launch (if applicable) the object's environment.\n   * @return {q.promise} A promise which will resolve when the environment is\n   *     ready to test.\n   */\n\n\n  _createClass(Direct, [{\n    key: \"setupDriverEnv\",\n    value: function setupDriverEnv() {\n      switch (this.config_.capabilities.browserName) {\n        case 'chrome':\n          logger.info('Using ChromeDriver directly...');\n          break;\n\n        case 'firefox':\n          logger.info('Using FirefoxDriver directly...');\n          break;\n\n        default:\n          throw new exitCodes_1.BrowserError(logger, 'browserName ' + this.config_.capabilities.browserName + ' is not supported with directConnect.');\n      }\n\n      return q.fcall(function () {});\n    }\n    /**\n     * Create a new driver.\n     *\n     * @public\n     * @override\n     * @return webdriver instance\n     */\n\n  }, {\n    key: \"getNewDriver\",\n    value: function getNewDriver() {\n      var driver;\n\n      switch (this.config_.capabilities.browserName) {\n        case 'chrome':\n          var chromeDriverFile;\n\n          if (this.config_.chromeDriver) {\n            chromeDriverFile = this.config_.chromeDriver;\n          } else {\n            try {\n              var updateJson = path.resolve(SeleniumConfig.getSeleniumDir(), 'update-config.json');\n              var updateConfig = JSON.parse(fs.readFileSync(updateJson).toString());\n              chromeDriverFile = updateConfig.chrome.last;\n            } catch (e) {\n              throw new exitCodes_1.BrowserError(logger, 'Could not find update-config.json. ' + 'Run \\'webdriver-manager update\\' to download binaries.');\n            }\n          }\n\n          if (!fs.existsSync(chromeDriverFile)) {\n            throw new exitCodes_1.BrowserError(logger, 'Could not find chromedriver at ' + chromeDriverFile + '. Run \\'webdriver-manager update\\' to download binaries.');\n          }\n\n          var chromeService = new chrome_1.ServiceBuilder(chromeDriverFile).build(); // driver = ChromeDriver.createSession(new Capabilities(this.config_.capabilities),\n          // chromeService);\n          // TODO(ralphj): fix typings\n\n          driver = require('selenium-webdriver/chrome').Driver.createSession(new selenium_webdriver_1.Capabilities(this.config_.capabilities), chromeService);\n          break;\n\n        case 'firefox':\n          var geckoDriverFile;\n\n          if (this.config_.geckoDriver) {\n            geckoDriverFile = this.config_.geckoDriver;\n          } else {\n            try {\n              var _updateJson = path.resolve(SeleniumConfig.getSeleniumDir(), 'update-config.json');\n\n              var _updateConfig = JSON.parse(fs.readFileSync(_updateJson).toString());\n\n              geckoDriverFile = _updateConfig.gecko.last;\n            } catch (e) {\n              throw new exitCodes_1.BrowserError(logger, 'Could not find update-config.json. ' + 'Run \\'webdriver-manager update\\' to download binaries.');\n            }\n          }\n\n          if (!fs.existsSync(geckoDriverFile)) {\n            throw new exitCodes_1.BrowserError(logger, 'Could not find geckodriver at ' + geckoDriverFile + '. Run \\'webdriver-manager update\\' to download binaries.');\n          } // TODO (mgiambalvo): Turn this into an import when the selenium typings are updated.\n\n\n          var FirefoxServiceBuilder = require('selenium-webdriver/firefox').ServiceBuilder;\n\n          var firefoxService = new FirefoxServiceBuilder(geckoDriverFile).build(); // TODO(mgiambalvo): Fix typings.\n\n          driver = require('selenium-webdriver/firefox').Driver.createSession(new selenium_webdriver_1.Capabilities(this.config_.capabilities), firefoxService);\n          break;\n\n        default:\n          throw new exitCodes_1.BrowserError(logger, 'browserName ' + this.config_.capabilities.browserName + ' is not supported with directConnect.');\n      }\n\n      this.drivers_.push(driver);\n      return driver;\n    }\n  }]);\n\n  return Direct;\n}(driverProvider_1.DriverProvider);\n\nexports.Direct = Direct; //# sourceMappingURL=direct.js.map","map":null,"metadata":{},"sourceType":"script"}