{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _createClass = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createClass\").default;\n\nvar _get = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/get\").default;\n\nvar _getPrototypeOf = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/getPrototypeOf\").default;\n\nvar _inherits = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/inherits\").default;\n\nvar _createSuper = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createSuper\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * This is an implementation of the Local Driver Provider.\n * It is responsible for setting up the account object, tearing\n * it down, and setting up the driver correctly.\n *\n * TODO - it would be nice to do this in the launcher phase,\n * so that we only start the local selenium once per entire launch.\n */\n\nvar fs = require(\"fs\");\n\nvar path = require(\"path\");\n\nvar q = require(\"q\");\n\nvar exitCodes_1 = require(\"../exitCodes\");\n\nvar logger_1 = require(\"../logger\");\n\nvar driverProvider_1 = require(\"./driverProvider\");\n\nvar SeleniumConfig = require('webdriver-manager/built/lib/config').Config;\n\nvar remote = require('selenium-webdriver/remote');\n\nvar logger = new logger_1.Logger('local');\n\nvar Local = /*#__PURE__*/function (_driverProvider_1$Dri) {\n  _inherits(Local, _driverProvider_1$Dri);\n\n  var _super = _createSuper(Local);\n\n  function Local(config) {\n    var _this;\n\n    _classCallCheck(this, Local);\n\n    _this = _super.call(this, config);\n    _this.server_ = null;\n    return _this;\n  }\n  /**\n   * Helper to locate the default jar path if none is provided by the user.\n   * @private\n   */\n\n\n  _createClass(Local, [{\n    key: \"addDefaultBinaryLocs_\",\n    value: function addDefaultBinaryLocs_() {\n      if (!this.config_.seleniumServerJar) {\n        logger.debug('Attempting to find the SeleniumServerJar in the default ' + 'location used by webdriver-manager');\n\n        try {\n          var updateJson = path.resolve(SeleniumConfig.getSeleniumDir(), 'update-config.json');\n          var updateConfig = JSON.parse(fs.readFileSync(updateJson).toString());\n          this.config_.seleniumServerJar = updateConfig.standalone.last;\n        } catch (err) {\n          throw new exitCodes_1.BrowserError(logger, 'No update-config.json found.' + ' Run \\'webdriver-manager update\\' to download binaries.');\n        }\n      }\n\n      if (!fs.existsSync(this.config_.seleniumServerJar)) {\n        throw new exitCodes_1.BrowserError(logger, 'No selenium server jar found at ' + this.config_.seleniumServerJar + '. Run \\'webdriver-manager update\\' to download binaries.');\n      }\n\n      if (this.config_.capabilities.browserName === 'chrome') {\n        if (!this.config_.chromeDriver) {\n          logger.debug('Attempting to find the chromedriver binary in the default ' + 'location used by webdriver-manager');\n\n          try {\n            var _updateJson = path.resolve(SeleniumConfig.getSeleniumDir(), 'update-config.json');\n\n            var _updateConfig = JSON.parse(fs.readFileSync(_updateJson).toString());\n\n            this.config_.chromeDriver = _updateConfig.chrome.last;\n          } catch (err) {\n            throw new exitCodes_1.BrowserError(logger, 'No update-config.json found. ' + 'Run \\'webdriver-manager update\\' to download binaries.');\n          }\n        } // Check if file exists, if not try .exe or fail accordingly\n\n\n        if (!fs.existsSync(this.config_.chromeDriver)) {\n          if (fs.existsSync(this.config_.chromeDriver + '.exe')) {\n            this.config_.chromeDriver += '.exe';\n          } else {\n            throw new exitCodes_1.BrowserError(logger, 'Could not find chromedriver at ' + this.config_.chromeDriver + '. Run \\'webdriver-manager update\\' to download binaries.');\n          }\n        }\n      }\n\n      if (this.config_.capabilities.browserName === 'firefox') {\n        if (!this.config_.geckoDriver) {\n          logger.debug('Attempting to find the gecko driver binary in the default ' + 'location used by webdriver-manager');\n\n          try {\n            var _updateJson2 = path.resolve(SeleniumConfig.getSeleniumDir(), 'update-config.json');\n\n            var _updateConfig2 = JSON.parse(fs.readFileSync(_updateJson2).toString());\n\n            this.config_.geckoDriver = _updateConfig2.gecko.last;\n          } catch (err) {\n            throw new exitCodes_1.BrowserError(logger, 'No update-config.json found. ' + 'Run \\'webdriver-manager update\\' to download binaries.');\n          }\n        } // Check if file exists, if not try .exe or fail accordingly\n\n\n        if (!fs.existsSync(this.config_.geckoDriver)) {\n          if (fs.existsSync(this.config_.geckoDriver + '.exe')) {\n            this.config_.geckoDriver += '.exe';\n          } else {\n            throw new exitCodes_1.BrowserError(logger, 'Could not find gecko driver at ' + this.config_.geckoDriver + '. Run \\'webdriver-manager update\\' to download binaries.');\n          }\n        }\n      }\n    }\n    /**\n     * Configure and launch (if applicable) the object's environment.\n     * @public\n     * @return {q.promise} A promise which will resolve when the environment is\n     *     ready to test.\n     */\n\n  }, {\n    key: \"setupDriverEnv\",\n    value: function setupDriverEnv() {\n      var _this2 = this;\n\n      this.addDefaultBinaryLocs_();\n      logger.info('Starting selenium standalone server...');\n      var serverConf = this.config_.localSeleniumStandaloneOpts || {}; // If args or port is not set use seleniumArgs and seleniumPort\n      // for backward compatibility\n\n      if (serverConf.args === undefined) {\n        serverConf.args = this.config_.seleniumArgs || [];\n      }\n\n      if (serverConf.jvmArgs === undefined) {\n        serverConf.jvmArgs = this.config_.jvmArgs || [];\n      } else {\n        if (!Array.isArray(serverConf.jvmArgs)) {\n          throw new exitCodes_1.ConfigError(logger, 'jvmArgs should be an array.');\n        }\n      }\n\n      if (serverConf.port === undefined) {\n        serverConf.port = this.config_.seleniumPort;\n      } // configure server\n\n\n      if (this.config_.chromeDriver) {\n        serverConf.jvmArgs.push('-Dwebdriver.chrome.driver=' + this.config_.chromeDriver);\n      }\n\n      if (this.config_.geckoDriver) {\n        serverConf.jvmArgs.push('-Dwebdriver.gecko.driver=' + this.config_.geckoDriver);\n      }\n\n      this.server_ = new remote.SeleniumServer(this.config_.seleniumServerJar, serverConf);\n      var deferred = q.defer(); // start local server, grab hosted address, and resolve promise\n\n      this.server_.start(this.config_.seleniumServerStartTimeout).then(function (url) {\n        logger.info('Selenium standalone server started at ' + url);\n        return _this2.server_.address();\n      }).then(function (address) {\n        _this2.config_.seleniumAddress = address;\n        deferred.resolve();\n      }).catch(function (err) {\n        deferred.reject(err);\n      });\n      return deferred.promise;\n    }\n    /**\n     * Teardown and destroy the environment and do any associated cleanup.\n     * Shuts down the drivers and server.\n     *\n     * @public\n     * @override\n     * @return {q.promise} A promise which will resolve when the environment\n     *     is down.\n     */\n\n  }, {\n    key: \"teardownEnv\",\n    value: function teardownEnv() {\n      var _this3 = this;\n\n      return _get(_getPrototypeOf(Local.prototype), \"teardownEnv\", this).call(this).then(function () {\n        logger.info('Shutting down selenium standalone server.');\n        return _this3.server_.stop();\n      });\n    }\n  }]);\n\n  return Local;\n}(driverProvider_1.DriverProvider);\n\nexports.Local = Local; //# sourceMappingURL=local.js.map","map":null,"metadata":{},"sourceType":"script"}