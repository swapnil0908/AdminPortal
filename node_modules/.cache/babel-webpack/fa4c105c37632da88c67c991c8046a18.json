{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _createClass = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createClass\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar fs = require(\"fs\");\n\nvar path = require(\"path\"); // Will use chalk if chalk is available to add color to console logging\n\n\nvar chalk;\nvar printRed;\nvar printYellow;\nvar printGray;\n\ntry {\n  chalk = require('chalk');\n  printRed = chalk.red;\n  printYellow = chalk.yellow;\n  printGray = chalk.gray;\n} catch (e) {\n  printRed = printYellow = printGray = function printGray(msg) {\n    return msg;\n  };\n}\n\nvar LogLevel;\n\n(function (LogLevel) {\n  LogLevel[LogLevel[\"ERROR\"] = 0] = \"ERROR\";\n  LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n  LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n  LogLevel[LogLevel[\"DEBUG\"] = 3] = \"DEBUG\";\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\n\nvar WriteTo;\n\n(function (WriteTo) {\n  WriteTo[WriteTo[\"CONSOLE\"] = 0] = \"CONSOLE\";\n  WriteTo[WriteTo[\"FILE\"] = 1] = \"FILE\";\n  WriteTo[WriteTo[\"BOTH\"] = 2] = \"BOTH\";\n  WriteTo[WriteTo[\"NONE\"] = 3] = \"NONE\";\n})(WriteTo = exports.WriteTo || (exports.WriteTo = {}));\n\nvar logFile = 'webdriver.log'; // the default log file name\n\n/**\n * Logger class adds timestamp output, log levels, and identifiers to help\n * when debugging. Also could write to console, file, both, or none.\n */\n\nvar Logger = /*#__PURE__*/function () {\n  /**\n   * Creates a logger instance with an ID for the logger.\n   * @constructor\n   */\n  function Logger(id) {\n    _classCallCheck(this, Logger);\n\n    this.id = id;\n  }\n  /**\n   * Set up the write location. If writing to a file, get the file descriptor.\n   * @param writeTo The enum for where to write the logs.\n   * @param opt_logFile An optional parameter to override the log file location.\n   */\n\n\n  _createClass(Logger, [{\n    key: \"info\",\n    value:\n    /**\n     * Log INFO\n     * @param ...msgs multiple arguments to be logged.\n     */\n    function info() {\n      for (var _len = arguments.length, msgs = new Array(_len), _key = 0; _key < _len; _key++) {\n        msgs[_key] = arguments[_key];\n      }\n\n      this.log_(LogLevel.INFO, msgs);\n    }\n    /**\n     * Log DEBUG\n     * @param ...msgs multiple arguments to be logged.\n     */\n\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      for (var _len2 = arguments.length, msgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        msgs[_key2] = arguments[_key2];\n      }\n\n      this.log_(LogLevel.DEBUG, msgs);\n    }\n    /**\n     * Log WARN\n     * @param ...msgs multiple arguments to be logged.\n     */\n\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      for (var _len3 = arguments.length, msgs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        msgs[_key3] = arguments[_key3];\n      }\n\n      this.log_(LogLevel.WARN, msgs);\n    }\n    /**\n     * Log ERROR\n     * @param ...msgs multiple arguments to be logged.\n     */\n\n  }, {\n    key: \"error\",\n    value: function error() {\n      for (var _len4 = arguments.length, msgs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        msgs[_key4] = arguments[_key4];\n      }\n\n      this.log_(LogLevel.ERROR, msgs);\n    }\n    /**\n     * For the log level set, check to see if the messages should be logged.\n     * @param logLevel The log level of the message.\n     * @param msgs The messages to be logged\n     */\n\n  }, {\n    key: \"log_\",\n    value: function log_(logLevel, msgs) {\n      switch (Logger.logLevel) {\n        case LogLevel.ERROR:\n          if (logLevel <= LogLevel.ERROR) {\n            this.print_(logLevel, msgs);\n          }\n\n          break;\n\n        case LogLevel.WARN:\n          if (logLevel <= LogLevel.WARN) {\n            this.print_(logLevel, msgs);\n          }\n\n          break;\n\n        case LogLevel.INFO:\n          if (logLevel <= LogLevel.INFO) {\n            this.print_(logLevel, msgs);\n          }\n\n          break;\n\n        case LogLevel.DEBUG:\n          if (logLevel <= LogLevel.DEBUG) {\n            this.print_(logLevel, msgs);\n          }\n\n          break;\n\n        default:\n          throw new Error('Log level undefined');\n      }\n    }\n    /**\n     * Format with timestamp, log level, identifier, and message and log to\n     * specified medium (console, file, both, none).\n     * @param logLevel The log level of the message.\n     * @param msgs The messages to be logged.\n     */\n\n  }, {\n    key: \"print_\",\n    value: function print_(logLevel, msgs) {\n      var consoleLog = '';\n      var fileLog = '';\n\n      if (Logger.showTimestamp) {\n        consoleLog += Logger.timestamp_(WriteTo.CONSOLE);\n        fileLog += Logger.timestamp_(WriteTo.FILE);\n      }\n\n      consoleLog += Logger.level_(logLevel, this.id, WriteTo.CONSOLE);\n      fileLog += Logger.level_(logLevel, this.id, WriteTo.FILE);\n\n      if (Logger.showId) {\n        consoleLog += Logger.id_(logLevel, this.id, WriteTo.CONSOLE);\n        fileLog += Logger.id_(logLevel, this.id, WriteTo.FILE);\n      }\n\n      consoleLog += ' -';\n      fileLog += ' - ';\n\n      switch (Logger.writeTo) {\n        case WriteTo.CONSOLE:\n          msgs.unshift(consoleLog);\n          console.log.apply(console, msgs);\n          break;\n\n        case WriteTo.FILE:\n          // for the first line written to the file, add a space\n          if (!Logger.firstWrite) {\n            fs.writeSync(Logger.fd, '\\n');\n            Logger.firstWrite = true;\n          }\n\n          fileLog += ' ' + Logger.msgToFile_(msgs);\n          fs.writeSync(Logger.fd, fileLog + '\\n');\n          break;\n\n        case WriteTo.BOTH:\n          // for the first line written to the file, add a space\n          if (!Logger.firstWrite) {\n            fs.writeSync(Logger.fd, '\\n');\n            Logger.firstWrite = true;\n          }\n\n          fileLog += ' ' + Logger.msgToFile_(msgs);\n          fs.writeSync(Logger.fd, fileLog + '\\n');\n          msgs.unshift(consoleLog);\n          console.log.apply(console, msgs);\n          break;\n\n        case WriteTo.NONE:\n          break;\n      }\n    }\n    /**\n     * Get a timestamp formatted with [hh:mm:ss]\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted timestamp\n     */\n\n  }], [{\n    key: \"setWrite\",\n    value: function setWrite(writeTo, opt_logFile) {\n      if (opt_logFile) {\n        logFile = opt_logFile;\n      }\n\n      Logger.writeTo = writeTo;\n\n      if (Logger.writeTo == WriteTo.FILE || Logger.writeTo == WriteTo.BOTH) {\n        Logger.fd = fs.openSync(path.resolve(logFile), 'a');\n        Logger.firstWrite = false;\n      }\n    }\n  }, {\n    key: \"timestamp_\",\n    value: function timestamp_(writeTo) {\n      var d = new Date();\n      var ts = '[';\n      var hours = d.getHours() < 10 ? '0' + d.getHours() : d.getHours();\n      var minutes = d.getMinutes() < 10 ? '0' + d.getMinutes() : d.getMinutes();\n      var seconds = d.getSeconds() < 10 ? '0' + d.getSeconds() : d.getSeconds();\n\n      if (writeTo == WriteTo.CONSOLE) {\n        ts += printGray(hours + ':' + minutes + ':' + seconds) + ']';\n      } else {\n        ts += hours + ':' + minutes + ':' + seconds + ']';\n      }\n\n      ts += ' ';\n      return ts;\n    }\n    /**\n     * Get the identifier of the logger as '/<id>'\n     * @param logLevel The log level of the message.\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted id\n     */\n\n  }, {\n    key: \"id_\",\n    value: function id_(logLevel, id, writeTo) {\n      var level = LogLevel[logLevel].toString();\n\n      if (writeTo === WriteTo.FILE) {\n        return '/' + id;\n      } else if (logLevel === LogLevel.ERROR) {\n        return printRed('/' + id);\n      } else if (logLevel === LogLevel.WARN) {\n        return printYellow('/' + id);\n      } else {\n        return '/' + id;\n      }\n    }\n    /**\n     * Get the log level formatted with the first letter. For info, it is I.\n     * @param logLevel The log level of the message.\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted log level\n     */\n\n  }, {\n    key: \"level_\",\n    value: function level_(logLevel, id, writeTo) {\n      var level = LogLevel[logLevel].toString();\n\n      if (writeTo === WriteTo.FILE) {\n        return level[0];\n      } else if (logLevel === LogLevel.ERROR) {\n        return printRed(level[0]);\n      } else if (logLevel === LogLevel.WARN) {\n        return printYellow(level[0]);\n      } else {\n        return level[0];\n      }\n    }\n    /**\n     * Convert the list of messages to a single string message.\n     * @param msgs The list of messages.\n     * @return The string of the formatted messages\n     */\n\n  }, {\n    key: \"msgToFile_\",\n    value: function msgToFile_(msgs) {\n      var log = '';\n\n      for (var pos = 0; pos < msgs.length; pos++) {\n        var msg = msgs[pos];\n        var ret = void 0;\n\n        if (typeof msg === 'object') {\n          ret = JSON.stringify(msg);\n        } else {\n          ret = msg;\n        }\n\n        if (pos !== msgs.length - 1) {\n          ret += ' ';\n        }\n\n        log += ret;\n      }\n\n      return log;\n    }\n  }]);\n\n  return Logger;\n}();\n\nLogger.logLevel = LogLevel.INFO;\nLogger.showTimestamp = true;\nLogger.showId = true;\nLogger.writeTo = WriteTo.CONSOLE;\nLogger.firstWrite = false;\nexports.Logger = Logger; //# sourceMappingURL=logger.js.map","map":null,"metadata":{},"sourceType":"script"}