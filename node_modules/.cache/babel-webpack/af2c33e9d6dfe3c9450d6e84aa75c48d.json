{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\").default;\n\nvar _classCallCheck = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _createClass = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createClass\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar glob = require(\"glob\");\n\nvar path = require(\"path\");\n\nvar exitCodes_1 = require(\"./exitCodes\");\n\nvar logger_1 = require(\"./logger\");\n\nvar logger = new logger_1.Logger('configParser'); // Coffee is required here to enable config files written in coffee-script.\n\ntry {\n  require('coffee-script').register();\n} catch (e) {// Intentionally blank - ignore if coffee-script is not available.\n} // CoffeeScript lost the hyphen in the module name a long time ago, all new version are named this:\n\n\ntry {\n  require('coffeescript').register();\n} catch (e) {// Intentionally blank - ignore if coffeescript is not available.\n} // LiveScript is required here to enable config files written in LiveScript.\n\n\ntry {\n  require('LiveScript');\n} catch (e) {// Intentionally blank - ignore if LiveScript is not available.\n}\n\nvar ConfigParser = /*#__PURE__*/function () {\n  function ConfigParser() {\n    _classCallCheck(this, ConfigParser);\n\n    // Default configuration.\n    this.config_ = {\n      specs: [],\n      multiCapabilities: [],\n      verboseMultiSessions: false,\n      rootElement: '',\n      allScriptsTimeout: 11000,\n      getPageTimeout: 10000,\n      params: {},\n      framework: 'jasmine',\n      jasmineNodeOpts: {\n        showColors: true,\n        defaultTimeoutInterval: 30 * 1000\n      },\n      seleniumArgs: [],\n      mochaOpts: {\n        ui: 'bdd',\n        reporter: 'list'\n      },\n      configDir: './',\n      noGlobals: false,\n      plugins: [],\n      skipSourceMapSupport: false,\n      ng12Hybrid: false\n    };\n  }\n  /**\n   * Resolve a list of file patterns into a list of individual file paths.\n   *\n   * @param {Array.<string> | string} patterns\n   * @param {=boolean} opt_omitWarnings Whether to omit did not match warnings\n   * @param {=string} opt_relativeTo Path to resolve patterns against\n   *\n   * @return {Array} The resolved file paths.\n   */\n\n\n  _createClass(ConfigParser, [{\n    key: \"addConfig_\",\n    value:\n    /**\n     * Add the options in the parameter config to this runner instance.\n     *\n     * @private\n     * @param {Object} additionalConfig\n     * @param {string} relativeTo the file path to resolve paths against\n     */\n    function addConfig_(additionalConfig, relativeTo) {\n      // All filepaths should be kept relative to the current config location.\n      // This will not affect absolute paths.\n      ['seleniumServerJar', 'chromeDriver', 'firefoxPath', 'frameworkPath', 'geckoDriver', 'onPrepare'].forEach(function (name) {\n        if (additionalConfig[name] && typeof additionalConfig[name] === 'string') {\n          additionalConfig[name] = path.resolve(relativeTo, additionalConfig[name]);\n        }\n      });\n      merge_(this.config_, additionalConfig);\n    }\n    /**\n     * Public function specialized towards merging in a file's config\n     *\n     * @public\n     * @param {String} filename\n     */\n\n  }, {\n    key: \"addFileConfig\",\n    value: function addFileConfig(filename) {\n      if (!filename) {\n        return this;\n      }\n\n      var filePath = path.resolve(process.cwd(), filename);\n      var fileConfig;\n\n      try {\n        fileConfig = require(filePath).config;\n      } catch (e) {\n        throw new exitCodes_1.ConfigError(logger, 'failed loading configuration file ' + filename, e);\n      }\n\n      if (!fileConfig) {\n        throw new exitCodes_1.ConfigError(logger, 'configuration file ' + filename + ' did not export a config object');\n      }\n\n      fileConfig.configDir = path.dirname(filePath);\n      this.addConfig_(fileConfig, fileConfig.configDir);\n      return this;\n    }\n    /**\n     * Public function specialized towards merging in config from argv\n     *\n     * @public\n     * @param {Object} argv\n     */\n\n  }, {\n    key: \"addConfig\",\n    value: function addConfig(argv) {\n      this.addConfig_(argv, process.cwd());\n      return this;\n    }\n    /**\n     * Public getter for the final, computed config object\n     *\n     * @public\n     * @return {Object} config\n     */\n\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      return this.config_;\n    }\n  }], [{\n    key: \"resolveFilePatterns\",\n    value: function resolveFilePatterns(patterns, opt_omitWarnings, opt_relativeTo) {\n      var resolvedFiles = [];\n      var cwd = opt_relativeTo || process.cwd();\n      patterns = typeof patterns === 'string' ? [patterns] : patterns;\n\n      if (patterns) {\n        var _iterator = _createForOfIteratorHelper(patterns),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var fileName = _step.value;\n            var matches = glob.hasMagic(fileName) ? glob.sync(fileName, {\n              cwd: cwd\n            }) : [fileName];\n\n            if (!matches.length && !opt_omitWarnings) {\n              logger.warn('pattern ' + fileName + ' did not match any files.');\n            }\n\n            var _iterator2 = _createForOfIteratorHelper(matches),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var match = _step2.value;\n                var resolvedPath = path.resolve(cwd, match);\n                resolvedFiles.push(resolvedPath);\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      return resolvedFiles;\n    }\n    /**\n     * Returns only the specs that should run currently based on `config.suite`\n     *\n     * @return {Array} An array of globs locating the spec files\n     */\n\n  }, {\n    key: \"getSpecs\",\n    value: function getSpecs(config) {\n      var specs = [];\n\n      if (config.suite) {\n        config.suite.split(',').forEach(function (suite) {\n          var suiteList = config.suites ? config.suites[suite] : null;\n\n          if (suiteList == null) {\n            throw new exitCodes_1.ConfigError(logger, 'Unknown test suite: ' + suite);\n          }\n\n          union(specs, makeArray(suiteList));\n        });\n        return specs;\n      }\n\n      if (config.specs.length > 0) {\n        return config.specs;\n      }\n\n      Object.keys(config.suites || {}).forEach(function (suite) {\n        union(specs, makeArray(config.suites[suite]));\n      });\n      return specs;\n    }\n  }]);\n\n  return ConfigParser;\n}();\n\nexports.ConfigParser = ConfigParser;\n/**\n * Merge config objects together.\n *\n * @private\n * @param {Object} into\n * @param {Object} from\n *\n * @return {Object} The 'into' config.\n */\n\nvar merge_ = function merge_(into, from) {\n  for (var key in from) {\n    if (into[key] instanceof Object && !(into[key] instanceof Array) && !(into[key] instanceof Function)) {\n      merge_(into[key], from[key]);\n    } else {\n      into[key] = from[key];\n    }\n  }\n\n  return into;\n};\n/**\n * Returns the item if it's an array or puts the item in an array\n * if it was not one already.\n */\n\n\nvar makeArray = function makeArray(item) {\n  return Array.isArray(item) ? item : [item];\n};\n/**\n * Adds to an array all the elements in another array without adding any\n * duplicates\n *\n * @param {string[]} dest The array to add to\n * @param {string[]} src The array to copy from\n */\n\n\nvar union = function union(dest, src) {\n  var elems = {};\n\n  for (var key in dest) {\n    elems[dest[key]] = true;\n  }\n\n  for (var _key in src) {\n    if (!elems[src[_key]]) {\n      dest.push(src[_key]);\n      elems[src[_key]] = true;\n    }\n  }\n}; //# sourceMappingURL=configParser.js.map","map":null,"metadata":{},"sourceType":"script"}