{"ast":null,"code":"import _createClass from \"/Users/swapnil0908/Documents/AdminPortal/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Users/swapnil0908/Documents/AdminPortal/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport swal from 'sweetalert2';\nimport { InjectionToken, ChangeDetectionStrategy, Component, EventEmitter, Inject, Input, Output, ComponentFactoryResolver, Directive, HostListener, ViewContainerRef, TemplateRef, ApplicationRef, Host, Injector, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Represents an object of targets for <swal> partials (use with *swalPartial directive).\n * We must use thunks to access the swal.* functions listed below, because they get created after the first modal is\n * shown, so this object lets us reference those functions safely and in a statically-typed manner.\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nfunction SwalPartialComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0);\n  }\n}\n\nvar SwalPartialTargets = /*@__PURE__*/function () {\n  var SwalPartialTargets = function SwalPartialTargets() {\n    _classCallCheck(this, SwalPartialTargets);\n\n    this.title = function () {\n      return swal.getTitle();\n    };\n\n    this.content = function () {\n      return swal.getContent();\n    };\n    /**\n     * @deprecated Will be removed in the next major version, please use {\\@link SwalPartialTargets#actions} instead.\n     */\n\n\n    this.buttonsWrapper = function () {\n      return swal.getButtonsWrapper();\n    };\n\n    this.actions = function () {\n      return swal.getActions();\n    };\n\n    this.confirmButton = function () {\n      return swal.getConfirmButton();\n    };\n\n    this.cancelButton = function () {\n      return swal.getCancelButton();\n    };\n\n    this.footer = function () {\n      return swal.getFooter();\n    };\n  };\n\n  SwalPartialTargets.ɵfac = function SwalPartialTargets_Factory(t) {\n    return new (t || SwalPartialTargets)();\n  };\n\n  SwalPartialTargets.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: SwalPartialTargets,\n    factory: SwalPartialTargets.ɵfac\n  });\n  return SwalPartialTargets;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar SwalDefaults = new InjectionToken('SwalDefaults');\n/**\n * @param {?=} options\n * @return {?}\n */\n\nfunction swalDefaultsProvider() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return {\n    provide: SwalDefaults,\n    useValue: options\n  };\n}\n\nvar SwalComponent = /*@__PURE__*/function () {\n  var SwalComponent = /*#__PURE__*/function () {\n    /**\n     * @param {?} defaultSwalOptions\n     */\n    function SwalComponent(defaultSwalOptions) {\n      _classCallCheck(this, SwalComponent);\n\n      this.defaultSwalOptions = defaultSwalOptions;\n      /**\n       * Emits a BeforeOpenEvent when the modal DOM element has been created.\n       * Useful to perform DOM mutations before the modal is shown.\n       */\n\n      this.beforeOpen = new EventEmitter();\n      /**\n       * Emits an OpenEvent when the modal is shown.\n       */\n\n      this.open = new EventEmitter();\n      /**\n       * Emits a CloseEvent when modal get closed.\n       */\n\n      this.close = new EventEmitter();\n      /**\n       * Emits when the user clicks \"Confirm\".\n       * Bears a value when using \"input\", resolved \"preConfirm\", etc.\n       *\n       * Example:\n       *     public handleConfirm(email: string): void {\n       *         // ... save user email\n       *     }\n       */\n\n      this.confirm = new EventEmitter();\n      /**\n       * Emits when the user clicks \"Cancel\" (or dismisses the modal by any other way).\n       * By default, it will emit a string representing the reason for which the SweetAlert has been closed, or the\n       * value of a rejected \"preConfirm\".\n       *\n       * Example:\n       *     public handleCancel(reason: string): void {\n       *         // reason can be 'cancel', 'overlay', 'close', and 'timer'\n       *         // ... do something\n       *     }\n       */\n\n      this.cancel = new EventEmitter();\n      this.nativeSwal = swal;\n      this.isCurrentlyShown = false;\n      this.touchedProps = new Set();\n      this.markTouched = this.touchedProps.add.bind(this.touchedProps); //=> Force `this` scope of show() on this component\n      //   Useful for doing things like (click)=\"mySwal.show()\".\n\n      this.show = this.show.bind(this);\n    }\n    /**\n     * An object of SweetAlert2 native options, useful if:\n     *  - you don't want to use the \\@Inputs for practical/philosophical reasons ;\n     *  - there are missing \\@Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.\n     *\n     * /!\\ Be aware that the options defined in this object will override the \\@Inputs of the same name.\n     * @param {?} options\n     * @return {?}\n     */\n\n\n    _createClass(SwalComponent, [{\n      key: \"options\",\n      get:\n      /**\n       * @return {?}\n       */\n      function get() {\n        var _this = this;\n\n        var\n        /** @type {?} */\n        options = {}; //=> We will compute the options object based on the option keys that are known to have changed.\n        // That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially avoiding\n        // side effects.\n\n        this.touchedProps.forEach(function (prop) {\n          options[prop] =\n          /** @type {?} */\n          _this[prop];\n        });\n        return options;\n      }\n      /**\n       * @param {?} changes\n       * @return {?}\n       */\n      ,\n      set: function set(options) {\n        Object.assign(this, options);\n        Object.keys(options).forEach(this.markTouched);\n      }\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        Object.keys(changes).filter(function (prop) {\n          return prop !== 'options';\n        }).forEach(this.markTouched);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.isCurrentlyShown) {\n          swal.close();\n        }\n      }\n      /**\n       * Shows the SweetAlert.\n       *\n       * Returns the SweetAlert2 promise for convenience and use in code behind templates.\n       * Otherwise, (confirm)=\"myHandler($event)\" and (cancel)=\"myHandler($event)\" can be used in templates.\n       * @return {?}\n       */\n\n    }, {\n      key: \"show\",\n      value: function show() {\n        var _this2 = this;\n\n        //=> Build the SweetAlert2 options\n        var\n        /** @type {?} */\n        options = Object.assign({}, this.defaultSwalOptions, this.options, {\n          onBeforeOpen: function onBeforeOpen(modalElement) {\n            _this2.beforeOpen.emit({\n              modalElement: modalElement\n            });\n          },\n          onOpen: function onOpen(modalElement) {\n            _this2.isCurrentlyShown = true;\n\n            _this2.open.emit({\n              modalElement: modalElement\n            });\n          },\n          onClose: function onClose(modalElement) {\n            _this2.isCurrentlyShown = false;\n\n            _this2.close.emit({\n              modalElement: modalElement\n            });\n          }\n        }); //=> Show the Swal!\n\n        var\n        /** @type {?} */\n        promise = swal(options); //=> Handle (confirm) and (cancel) @Outputs\n        // tslint:disable-next-line:no-string-literal\n\n        var\n        /** @type {?} */\n        useRejections =\n        /** @type {?} */\n        options.useRejections;\n        promise.then(function (result) {\n          if (useRejections) {\n            _this2.confirm.emit(result);\n          } else if ('value' in result) {\n            _this2.confirm.emit(result.value);\n          } else {\n            _this2.cancel.emit(result.dismiss);\n          }\n        }, function (err) {\n          if (useRejections) {\n            _this2.cancel.emit(err);\n          }\n        }); //=> Return the unaltered promise\n\n        return promise;\n      }\n    }]);\n\n    return SwalComponent;\n  }();\n\n  SwalComponent.ɵfac = function SwalComponent_Factory(t) {\n    return new (t || SwalComponent)(ɵngcc0.ɵɵdirectiveInject(SwalDefaults));\n  };\n\n  SwalComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: SwalComponent,\n    selectors: [[\"swal\"]],\n    inputs: {\n      options: \"options\",\n      title: \"title\",\n      titleText: \"titleText\",\n      text: \"text\",\n      html: \"html\",\n      footer: \"footer\",\n      type: \"type\",\n      backdrop: \"backdrop\",\n      toast: \"toast\",\n      target: \"target\",\n      input: \"input\",\n      width: \"width\",\n      padding: \"padding\",\n      background: \"background\",\n      position: \"position\",\n      grow: \"grow\",\n      customClass: \"customClass\",\n      timer: \"timer\",\n      animation: \"animation\",\n      allowOutsideClick: \"allowOutsideClick\",\n      allowEscapeKey: \"allowEscapeKey\",\n      allowEnterKey: \"allowEnterKey\",\n      showConfirmButton: \"showConfirmButton\",\n      showCancelButton: \"showCancelButton\",\n      confirmButtonText: \"confirmButtonText\",\n      cancelButtonText: \"cancelButtonText\",\n      confirmButtonColor: \"confirmButtonColor\",\n      cancelButtonColor: \"cancelButtonColor\",\n      confirmButtonClass: \"confirmButtonClass\",\n      cancelButtonClass: \"cancelButtonClass\",\n      confirmButtonAriaLabel: \"confirmButtonAriaLabel\",\n      cancelButtonAriaLabel: \"cancelButtonAriaLabel\",\n      buttonsStyling: \"buttonsStyling\",\n      reverseButtons: \"reverseButtons\",\n      focusConfirm: \"focusConfirm\",\n      focusCancel: \"focusCancel\",\n      showCloseButton: \"showCloseButton\",\n      closeButtonAriaLabel: \"closeButtonAriaLabel\",\n      showLoaderOnConfirm: \"showLoaderOnConfirm\",\n      preConfirm: \"preConfirm\",\n      imageUrl: \"imageUrl\",\n      imageWidth: \"imageWidth\",\n      imageHeight: \"imageHeight\",\n      imageAlt: \"imageAlt\",\n      imageClass: \"imageClass\",\n      inputPlaceholder: \"inputPlaceholder\",\n      inputValue: \"inputValue\",\n      inputOptions: \"inputOptions\",\n      inputAutoTrim: \"inputAutoTrim\",\n      inputAttributes: \"inputAttributes\",\n      inputValidator: \"inputValidator\",\n      inputClass: \"inputClass\",\n      progressSteps: \"progressSteps\",\n      currentProgressStep: \"currentProgressStep\",\n      progressStepsDistance: \"progressStepsDistance\"\n    },\n    outputs: {\n      beforeOpen: \"beforeOpen\",\n      open: \"open\",\n      close: \"close\",\n      confirm: \"confirm\",\n      cancel: \"cancel\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function SwalComponent_Template(rf, ctx) {},\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return SwalComponent;\n}();\n\nvar SwalDirective = /*@__PURE__*/function () {\n  var SwalDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} viewContainerRef\n     * @param {?} resolver\n     */\n    function SwalDirective(viewContainerRef, resolver) {\n      _classCallCheck(this, SwalDirective);\n\n      this.viewContainerRef = viewContainerRef;\n      this.resolver = resolver;\n      /**\n       * Emits when the user clicks \"Confirm\".\n       * Bears a value when using \"input\", resolved \"preConfirm\", etc.\n       *\n       * Example:\n       *     public handleConfirm(email: string): void {\n       *         // ... save user email\n       *     }\n       */\n\n      this.confirm = new EventEmitter();\n      /**\n       * Emits when the user clicks \"Cancel\" (or dismisses the modal by any other way).\n       * By default, it will emit a string representing the reason for which the SweetAlert has been closed, or the\n       * value of a rejected \"preConfirm\".\n       *\n       * Example:\n       *     public handleCancel(reason: string): void {\n       *         // reason can be 'cancel', 'overlay', 'close', and 'timer'\n       *         // ... do something\n       *     }\n       */\n\n      this.cancel = new EventEmitter();\n    }\n    /**\n     * SweetAlert2 options or a SwalComponent instance.\n     * See the class doc block for more informations.\n     * @param {?} options\n     * @return {?}\n     */\n\n\n    _createClass(SwalDirective, [{\n      key: \"swal\",\n      set: function set(options) {\n        if (options instanceof SwalComponent) {\n          this.swalInstance = options;\n        } else if (Array.isArray(options)) {\n          this.swalOptions = swal.argsToParams(options);\n        } else {\n          this.swalOptions = options;\n        }\n      }\n      /**\n       * OnInit lifecycle handler.\n       * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and\n       * (cancel) outputs to reemit on the directive.\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        if (!this.swalInstance) {\n          var\n          /** @type {?} */\n          factory = this.resolver.resolveComponentFactory(SwalComponent);\n          this.swalRef = this.viewContainerRef.createComponent(factory);\n          this.swalInstance = this.swalRef.instance;\n        }\n      }\n      /**\n       * OnDestroy lifecycle handler.\n       * Destroys the dynamically-created SwalComponent and unsubscribes from that component's (confirm) and (cancel).\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.swalRef) {\n          this.swalRef.destroy();\n        }\n      }\n      /**\n       * Click handler.\n       * The directive listens for onclick events on its host element.\n       * When this happens, it shows the <swal> attached to this directive.\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onHostClicked\",\n      value: function onHostClicked(event) {\n        var _this3 = this;\n\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        event.stopPropagation();\n\n        if (this.swalOptions) {\n          this.swalInstance.options = this.swalOptions;\n        }\n\n        var\n        /** @type {?} */\n        confirmSub = this.swalInstance.confirm.asObservable().subscribe(function (v) {\n          return _this3.confirm.emit(v);\n        });\n        var\n        /** @type {?} */\n        cancelSub = this.swalInstance.cancel.asObservable().subscribe(function (v) {\n          return _this3.cancel.emit(v);\n        });\n        this.swalInstance.show().then(unsubscribe);\n        /**\n         * @return {?}\n         */\n\n        function unsubscribe() {\n          confirmSub.unsubscribe();\n          cancelSub.unsubscribe();\n        }\n      }\n    }]);\n\n    return SwalDirective;\n  }();\n\n  SwalDirective.ɵfac = function SwalDirective_Factory(t) {\n    return new (t || SwalDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver));\n  };\n\n  SwalDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SwalDirective,\n    selectors: [[\"\", \"swal\", \"\"]],\n    hostBindings: function SwalDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function SwalDirective_click_HostBindingHandler($event) {\n          return ctx.onHostClicked($event);\n        });\n      }\n    },\n    inputs: {\n      swal: \"swal\"\n    },\n    outputs: {\n      confirm: \"confirm\",\n      cancel: \"cancel\"\n    }\n  });\n  return SwalDirective;\n}();\n\nvar SwalPartialComponent = /*@__PURE__*/function () {\n  var SwalPartialComponent = function SwalPartialComponent() {\n    _classCallCheck(this, SwalPartialComponent);\n  };\n\n  SwalPartialComponent.ɵfac = function SwalPartialComponent_Factory(t) {\n    return new (t || SwalPartialComponent)();\n  };\n\n  SwalPartialComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: SwalPartialComponent,\n    selectors: [[\"ng-component\"]],\n    inputs: {\n      template: \"template\"\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngTemplateOutlet\"]],\n    template: function SwalPartialComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, SwalPartialComponent_ng_container_0_Template, 1, 0, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template);\n      }\n    },\n    directives: [ɵngcc1.NgTemplateOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return SwalPartialComponent;\n}();\n\nvar SwalPartialDirective = /*@__PURE__*/function () {\n  var SwalPartialDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} resolver\n     * @param {?} injector\n     * @param {?} app\n     * @param {?} templateRef\n     * @param {?} swalTargets\n     * @param {?} swalComponent\n     */\n    function SwalPartialDirective(resolver, injector, app, templateRef, swalTargets, swalComponent) {\n      _classCallCheck(this, SwalPartialDirective);\n\n      this.resolver = resolver;\n      this.injector = injector;\n      this.app = app;\n      this.templateRef = templateRef;\n      this.swalTargets = swalTargets;\n      this.swalComponent = swalComponent;\n    }\n    /**\n     * Subscribes to the the Sweet Alert appearance/disappearance to create/destroy the SwalPartialComponent that will\n     * receive the consumer's template.\n     * @return {?}\n     */\n\n\n    _createClass(SwalPartialDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this4 = this;\n\n        this.beforeOpenSubscription = this.swalComponent.beforeOpen.asObservable().subscribe(function () {\n          //=> Create the SwalPartialComponent on the target DOM node in the Sweet Alert\n          var\n          /** @type {?} */\n          targetEl = _this4.swalPartial ? _this4.swalPartial() : _this4.swalTargets.content();\n\n          var\n          /** @type {?} */\n          factory = _this4.resolver.resolveComponentFactory(SwalPartialComponent);\n\n          _this4.partialRef = factory.create(_this4.injector, [], targetEl); //=> Apply the consumer's template on the component\n\n          _this4.partialRef.instance.template = _this4.templateRef; //=> Make the Angular app aware of that detached view so change detection works\n\n          _this4.app.attachView(_this4.partialRef.hostView);\n        });\n        this.closeSubscription = this.swalComponent.close.asObservable().subscribe(function () {\n          //=> Detach the partial component from the app and destroy it\n          _this4.app.detachView(_this4.partialRef.hostView);\n\n          _this4.partialRef.destroy();\n        });\n      }\n      /**\n       * Unsubscribes from the Sweet Alert appearance/disappearance.\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.beforeOpenSubscription.unsubscribe();\n        this.closeSubscription.unsubscribe();\n      }\n    }]);\n\n    return SwalPartialDirective;\n  }();\n\n  SwalPartialDirective.ɵfac = function SwalPartialDirective_Factory(t) {\n    return new (t || SwalPartialDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(SwalPartialTargets), ɵngcc0.ɵɵdirectiveInject(SwalComponent, 1));\n  };\n\n  SwalPartialDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SwalPartialDirective,\n    selectors: [[\"\", \"swalPartial\", \"\"]],\n    inputs: {\n      swalPartial: \"swalPartial\"\n    }\n  });\n  return SwalPartialDirective;\n}();\n\nvar SweetAlert2Module = /*@__PURE__*/function () {\n  var SweetAlert2Module = /*#__PURE__*/function () {\n    function SweetAlert2Module() {\n      _classCallCheck(this, SweetAlert2Module);\n    }\n\n    _createClass(SweetAlert2Module, null, [{\n      key: \"forRoot\",\n      value:\n      /**\n       * @param {?=} defaultSwalOptions\n       * @return {?}\n       */\n      function forRoot(defaultSwalOptions) {\n        return {\n          ngModule: SweetAlert2Module,\n          providers: [swalDefaultsProvider(defaultSwalOptions)]\n        };\n      }\n    }]);\n\n    return SweetAlert2Module;\n  }();\n\n  SweetAlert2Module.ɵfac = function SweetAlert2Module_Factory(t) {\n    return new (t || SweetAlert2Module)();\n  };\n\n  SweetAlert2Module.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: SweetAlert2Module\n  });\n  SweetAlert2Module.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [SwalPartialTargets],\n    imports: [[CommonModule]]\n  });\n  return SweetAlert2Module;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SweetAlert2Module, {\n    declarations: function declarations() {\n      return [SwalComponent, SwalPartialDirective, SwalPartialComponent, SwalDirective];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [SwalComponent, SwalPartialDirective, SwalDirective];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { SwalPartialTargets, SwalComponent, SwalDirective, SwalPartialDirective, SweetAlert2Module, SwalDefaults as ɵa, swalDefaultsProvider as ɵb, SwalPartialComponent as ɵc }; //# sourceMappingURL=toverux-ngx-sweetalert2.js.map","map":null,"metadata":{},"sourceType":"module"}