{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/toConsumableArray\").default;\n\nvar _createForOfIteratorHelper = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\").default;\n\nvar _createClass = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createClass\").default;\n\nvar _assertThisInitialized = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/assertThisInitialized\").default;\n\nvar _inherits = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/inherits\").default;\n\nvar _createSuper = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createSuper\").default;\n\nvar _classCallCheck = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar blocking_proxy_1 = require(\"blocking-proxy\");\n\nvar selenium_webdriver_1 = require(\"selenium-webdriver\");\n\nvar url = require(\"url\");\n\nvar webdriver_js_extender_1 = require(\"webdriver-js-extender\");\n\nvar element_1 = require(\"./element\");\n\nvar expectedConditions_1 = require(\"./expectedConditions\");\n\nvar locators_1 = require(\"./locators\");\n\nvar logger_1 = require(\"./logger\");\n\nvar clientSideScripts = require('./clientsidescripts'); // TODO: fix the typings for selenium-webdriver/lib/command\n\n\nvar Command = require('selenium-webdriver/lib/command').Command;\n\nvar CommandName = require('selenium-webdriver/lib/command').Name; // jshint browser: true\n\n\nvar DEFER_LABEL = 'NG_DEFER_BOOTSTRAP!';\nvar DEFAULT_RESET_URL = 'data:text/html,<html></html>';\nvar DEFAULT_GET_PAGE_TIMEOUT = 10000;\nvar logger = new logger_1.Logger('protractor'); // TODO(cnishina): either remove for loop entirely since this does not export anything\n// the user might need since everything is composed (with caveat that this could be a\n// potential breaking change) or export the types with `export * from 'selenium-webdriver'`;\n\n/*\n * Mix in other webdriver functionality to be accessible via protractor.\n */\n\nfor (var foo in require('selenium-webdriver')) {\n  exports[foo] = require('selenium-webdriver')[foo];\n} // Explicitly define types for webdriver.WebDriver and ExtendedWebDriver.\n// We do this because we use composition over inheritance to implement polymorphism, and therefore\n// we don't want to inherit WebDriver's constructor.\n\n\nvar AbstractWebDriver = function AbstractWebDriver() {\n  _classCallCheck(this, AbstractWebDriver);\n};\n\nexports.AbstractWebDriver = AbstractWebDriver;\n\nvar AbstractExtendedWebDriver = /*#__PURE__*/function (_AbstractWebDriver) {\n  _inherits(AbstractExtendedWebDriver, _AbstractWebDriver);\n\n  var _super = _createSuper(AbstractExtendedWebDriver);\n\n  function AbstractExtendedWebDriver() {\n    _classCallCheck(this, AbstractExtendedWebDriver);\n\n    return _super.apply(this, arguments);\n  }\n\n  return AbstractExtendedWebDriver;\n}(AbstractWebDriver);\n\nexports.AbstractExtendedWebDriver = AbstractExtendedWebDriver;\n/**\n * Mix a function from one object onto another. The function will still be\n * called in the context of the original object.  Any arguments of type\n * `ElementFinder` will be unwrapped to their underlying `WebElement` instance\n *\n * @private\n * @param {Object} to\n * @param {Object} from\n * @param {string} fnName\n * @param {function=} setupFn\n */\n\nfunction ptorMixin(to, from, fnName, setupFn) {\n  to[fnName] = function () {\n    var args = arguments;\n\n    for (var i = 0; i < args.length; i++) {\n      if (args[i] instanceof element_1.ElementFinder) {\n        args[i] = args[i].getWebElement();\n      }\n    }\n\n    var run = function run() {\n      return from[fnName].apply(from, args);\n    };\n\n    if (setupFn) {\n      var setupResult = setupFn();\n\n      if (setupResult && typeof setupResult.then === 'function') {\n        return setupResult.then(run);\n      }\n    }\n\n    return run();\n  };\n}\n\n;\n/**\n * Build the helper 'element' function for a given instance of Browser.\n *\n * @private\n * @param {Browser} browser A browser instance.\n * @returns {function(webdriver.Locator): ElementFinder}\n */\n\nfunction buildElementHelper(browser) {\n  var element = function element(locator) {\n    return new element_1.ElementArrayFinder(browser).all(locator).toElementFinder_();\n  };\n\n  element.all = function (locator) {\n    return new element_1.ElementArrayFinder(browser).all(locator);\n  };\n\n  return element;\n}\n\n;\n\nvar ProtractorBrowser = /*@__PURE__*/function () {\n  var ProtractorBrowser = /*#__PURE__*/function (_AbstractExtendedWebD) {\n    _inherits(ProtractorBrowser, _AbstractExtendedWebD);\n\n    var _super2 = _createSuper(ProtractorBrowser);\n\n    function ProtractorBrowser(webdriverInstance, opt_baseUrl, opt_rootElement, opt_untrackOutstandingTimeouts, opt_blockingProxyUrl) {\n      var _this;\n\n      _classCallCheck(this, ProtractorBrowser);\n\n      _this = _super2.call(this); // These functions should delegate to the webdriver instance, but should\n      // wait for Angular to sync up before performing the action. This does not\n      // include functions which are overridden by protractor below.\n\n      var methodsToSync = ['getCurrentUrl', 'getPageSource', 'getTitle'];\n      var extendWDInstance;\n\n      try {\n        extendWDInstance = webdriver_js_extender_1.extend(webdriverInstance);\n      } catch (e) {\n        // Probably not a driver that can be extended (e.g. gotten using\n        // `directConnect: true` in the config)\n        extendWDInstance = webdriverInstance;\n      } // Mix all other driver functionality into Protractor.\n\n\n      Object.getOwnPropertyNames(selenium_webdriver_1.WebDriver.prototype).forEach(function (method) {\n        if (!_this[method] && typeof extendWDInstance[method] === 'function') {\n          if (methodsToSync.indexOf(method) !== -1) {\n            ptorMixin(_assertThisInitialized(_this), extendWDInstance, method, _this.waitForAngular.bind(_assertThisInitialized(_this)));\n          } else {\n            ptorMixin(_assertThisInitialized(_this), extendWDInstance, method);\n          }\n        }\n      });\n      _this.driver = extendWDInstance;\n\n      if (opt_blockingProxyUrl) {\n        logger.info('Starting BP client for ' + opt_blockingProxyUrl);\n        _this.bpClient = new blocking_proxy_1.BPClient(opt_blockingProxyUrl);\n      }\n\n      _this.element = buildElementHelper(_assertThisInitialized(_this));\n      _this.$ = element_1.build$(_this.element, selenium_webdriver_1.By);\n      _this.$$ = element_1.build$$(_this.element, selenium_webdriver_1.By);\n      _this.baseUrl = opt_baseUrl || '';\n      _this.getPageTimeout = DEFAULT_GET_PAGE_TIMEOUT;\n      _this.params = {};\n      _this.resetUrl = DEFAULT_RESET_URL;\n      var ng12Hybrid_ = false;\n      Object.defineProperty(_assertThisInitialized(_this), 'ng12Hybrid', {\n        get: function get() {\n          return ng12Hybrid_;\n        },\n        set: function set(ng12Hybrid) {\n          if (ng12Hybrid) {\n            logger.warn('You have set ng12Hybrid.  As of Protractor 4.1.0, ' + 'Protractor can automatically infer if you are using an ' + 'ngUpgrade app (as long as ng1 is loaded before you call ' + 'platformBrowserDynamic()), and this flag is no longer needed ' + 'for most users');\n          }\n\n          ng12Hybrid_ = ng12Hybrid;\n        }\n      });\n      _this.ready = _this.angularAppRoot(opt_rootElement || '').then(function () {\n        return _this.driver.getSession();\n      }).then(function (session) {\n        // Internet Explorer does not accept data URLs, which are the default\n        // reset URL for Protractor.\n        // Safari accepts data urls, but SafariDriver fails after one is used.\n        // PhantomJS produces a \"Detected a page unload event\" if we use data urls\n        var browserName = session.getCapabilities().get('browserName');\n\n        if (browserName === 'internet explorer' || browserName === 'safari' || browserName === 'phantomjs' || browserName === 'MicrosoftEdge') {\n          _this.resetUrl = 'about:blank';\n        }\n\n        return _assertThisInitialized(_this);\n      });\n      _this.trackOutstandingTimeouts_ = !opt_untrackOutstandingTimeouts;\n      _this.mockModules_ = [];\n\n      _this.addBaseMockModules_(); // set up expected conditions\n\n\n      _this.ExpectedConditions = new expectedConditions_1.ProtractorExpectedConditions(_assertThisInitialized(_this));\n      return _this;\n    }\n    /**\n     * The css selector for an element on which to find Angular. This is usually\n     * 'body' but if your ng-app is on a subsection of the page it may be\n     * a subelement.\n     *\n     * This property is deprecated - please use angularAppRoot() instead.\n     *\n     * @deprecated\n     * @type {string}\n     */\n\n\n    _createClass(ProtractorBrowser, [{\n      key: \"rootEl\",\n      get: function get() {\n        return this.internalRootEl;\n      }\n      /**\n       * Set the css selector for an element on which to find Angular. This is usually\n       * 'body' but if your ng-app is on a subsection of the page it may be\n       * a subelement.\n       *\n       * The change will be made within WebDriver's control flow, so that commands after\n       * this method is called use the new app root. Pass nothing to get a promise that\n       * resolves to the value of the selector.\n       *\n       * @param {string|webdriver.promise.Promise<string>} value The new selector.\n       * @returns A promise that resolves with the value of the selector.\n       */\n      ,\n      set: function set(value) {\n        this.angularAppRoot(value);\n      }\n    }, {\n      key: \"angularAppRoot\",\n      value: function angularAppRoot() {\n        var _this2 = this;\n\n        var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        return this.driver.controlFlow().execute(function () {\n          if (value != null) {\n            return selenium_webdriver_1.promise.when(value).then(function (value) {\n              _this2.internalRootEl = value;\n\n              if (_this2.bpClient) {\n                var bpCommandPromise = _this2.bpClient.setWaitParams(value); // Convert to webdriver promise as best as possible\n\n\n                return selenium_webdriver_1.promise.when(bpCommandPromise).then(function () {\n                  return _this2.internalRootEl;\n                });\n              }\n\n              return _this2.internalRootEl;\n            });\n          }\n\n          return selenium_webdriver_1.promise.when(_this2.internalRootEl);\n        }, \"Set angular root selector to \".concat(value));\n      }\n      /**\n       * If true, Protractor will not attempt to synchronize with the page before\n       * performing actions. This can be harmful because Protractor will not wait\n       * until $timeouts and $http calls have been processed, which can cause\n       * tests to become flaky. This should be used only when necessary, such as\n       * when a page continuously polls an API using $timeout.\n       *\n       * Initialized to `false` by the runner.\n       *\n       * This property is deprecated - please use waitForAngularEnabled instead.\n       *\n       * @deprecated\n       * @type {boolean}\n       */\n\n    }, {\n      key: \"ignoreSynchronization\",\n      get: function get() {\n        return this.internalIgnoreSynchronization;\n      }\n      /**\n       * If set to false, Protractor will not wait for Angular $http and $timeout\n       * tasks to complete before interacting with the browser. This can cause\n       * flaky tests, but should be used if, for instance, your app continuously\n       * polls an API with $timeout.\n       *\n       * Call waitForAngularEnabled() without passing a value to read the current\n       * state without changing it.\n       */\n      ,\n      set: function set(value) {\n        this.waitForAngularEnabled(!value);\n      }\n    }, {\n      key: \"waitForAngularEnabled\",\n      value: function waitForAngularEnabled() {\n        var _this3 = this;\n\n        var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n        if (enabled != null) {\n          var ret = this.driver.controlFlow().execute(function () {\n            return selenium_webdriver_1.promise.when(enabled).then(function (enabled) {\n              if (_this3.bpClient) {\n                logger.debug('Setting waitForAngular' + !enabled);\n\n                var bpCommandPromise = _this3.bpClient.setWaitEnabled(enabled); // Convert to webdriver promise as best as possible\n\n\n                return selenium_webdriver_1.promise.when(bpCommandPromise).then(function () {\n                  return enabled;\n                });\n              }\n            });\n          }, \"Set proxy synchronization enabled to \".concat(enabled));\n          this.internalIgnoreSynchronization = !enabled;\n          return ret;\n        }\n\n        return selenium_webdriver_1.promise.when(!this.ignoreSynchronization);\n      }\n      /**\n       * Get the processed configuration object that is currently being run. This\n       * will contain the specs and capabilities properties of the current runner\n       * instance.\n       *\n       * Set by the runner.\n       *\n       * @returns {webdriver.promise.Promise} A promise which resolves to the\n       * capabilities object.\n       */\n\n    }, {\n      key: \"getProcessedConfig\",\n      value: function getProcessedConfig() {\n        return null;\n      }\n      /**\n       * Fork another instance of browser for use in interactive tests.\n       *\n       * @example\n       * // Running with control flow enabled\n       * var fork = browser.forkNewDriverInstance();\n       * fork.get('page1'); // 'page1' gotten by forked browser\n       *\n       * // Running with control flow disabled\n       * var forked = await browser.forkNewDriverInstance().ready;\n       * await forked.get('page1'); // 'page1' gotten by forked browser\n       *\n       * @param {boolean=} useSameUrl Whether to navigate to current url on creation\n       * @param {boolean=} copyMockModules Whether to apply same mock modules on creation\n       * @param {boolean=} copyConfigUpdates Whether to copy over changes to `baseUrl` and similar\n       *   properties initialized to values in the the config.  Defaults to `true`\n       *\n       * @returns {ProtractorBrowser} A browser instance.\n       */\n\n    }, {\n      key: \"forkNewDriverInstance\",\n      value: function forkNewDriverInstance(useSameUrl, copyMockModules) {\n        var copyConfigUpdates = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        return null;\n      }\n      /**\n       * Restart the browser.  This is done by closing this browser instance and creating a new one.\n       * A promise resolving to the new instance is returned, and if this function was called on the\n       * global `browser` instance then Protractor will automatically overwrite the global `browser`\n       * variable.\n       *\n       * When restarting a forked browser, it is the caller's job to overwrite references to the old\n       * instance.\n       *\n       * This function behaves slightly differently depending on if the webdriver control flow is\n       * enabled.  If the control flow is enabled, the global `browser` object is synchronously\n       * replaced. If the control flow is disabled, the global `browser` is replaced asynchronously\n       * after the old driver quits.\n       *\n       * Set by the runner.\n       *\n       * @example\n       * // Running against global browser, with control flow enabled\n       * browser.get('page1');\n       * browser.restart();\n       * browser.get('page2'); // 'page2' gotten by restarted browser\n       *\n       * // Running against global browser, with control flow disabled\n       * await browser.get('page1');\n       * await browser.restart();\n       * await browser.get('page2'); // 'page2' gotten by restarted browser\n       *\n       * // Running against forked browsers, with the control flow enabled\n       * // In this case, you may prefer `restartSync` (documented below)\n       * var forked = browser.forkNewDriverInstance();\n       * fork.get('page1');\n       * fork.restart().then(function(fork) {\n       *   fork.get('page2'); // 'page2' gotten by restarted fork\n       * });\n       *\n       * // Running against forked browsers, with the control flow disabled\n       * var forked = await browser.forkNewDriverInstance().ready;\n       * await fork.get('page1');\n       * fork = await fork.restart();\n       * await fork.get('page2'); // 'page2' gotten by restarted fork\n       *\n       * // Unexpected behavior can occur if you save references to the global `browser`\n       * var savedBrowser = browser;\n       * browser.get('foo').then(function() {\n       *   console.log(browser === savedBrowser); // false\n       * });\n       * browser.restart();\n       *\n       * @returns {webdriver.promise.Promise<ProtractorBrowser>} A promise resolving to the restarted\n       *   browser\n       */\n\n    }, {\n      key: \"restart\",\n      value: function restart() {\n        return;\n      }\n      /**\n       * Like `restart`, but instead of returning a promise resolving to the new browser instance,\n       * returns the new browser instance directly.  Can only be used when the control flow is enabled.\n       *\n       * @example\n       * // Running against global browser\n       * browser.get('page1');\n       * browser.restartSync();\n       * browser.get('page2'); // 'page2' gotten by restarted browser\n       *\n       * // Running against forked browsers\n       * var forked = browser.forkNewDriverInstance();\n       * fork.get('page1');\n       * fork = fork.restartSync();\n       * fork.get('page2'); // 'page2' gotten by restarted fork\n       *\n       * @throws {TypeError} Will throw an error if the control flow is not enabled\n       * @returns {ProtractorBrowser} The restarted browser\n       */\n\n    }, {\n      key: \"restartSync\",\n      value: function restartSync() {\n        return;\n      }\n      /**\n       * Instead of using a single root element, search through all angular apps\n       * available on the page when finding elements or waiting for stability.\n       * Only compatible with Angular2.\n       */\n\n    }, {\n      key: \"useAllAngular2AppRoots\",\n      value: function useAllAngular2AppRoots() {\n        // The empty string is an invalid css selector, so we use it to easily\n        // signal to scripts to not find a root element.\n        this.angularAppRoot('');\n      }\n      /**\n       * The same as {@code webdriver.WebDriver.prototype.executeScript},\n       * but with a customized description for debugging.\n       *\n       * @private\n       * @param {!(string|Function)} script The script to execute.\n       * @param {string} description A description of the command for debugging.\n       * @param {...*} var_args The arguments to pass to the script.\n       * @returns {!webdriver.promise.Promise.<T>} A promise that will resolve to\n       * the scripts return value.\n       * @template T\n       */\n\n    }, {\n      key: \"executeScriptWithDescription\",\n      value: function executeScriptWithDescription(script, description) {\n        if (typeof script === 'function') {\n          script = 'return (' + script + ').apply(null, arguments);';\n        }\n\n        for (var _len = arguments.length, scriptArgs = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n          scriptArgs[_key - 2] = arguments[_key];\n        }\n\n        return this.driver.schedule(new Command(CommandName.EXECUTE_SCRIPT).setParameter('script', script).setParameter('args', scriptArgs), description);\n      }\n      /**\n       * The same as {@code webdriver.WebDriver.prototype.executeAsyncScript},\n       * but with a customized description for debugging.\n       *\n       * @private\n       * @param {!(string|Function)} script The script to execute.\n       * @param {string} description A description for debugging purposes.\n       * @param {...*} var_args The arguments to pass to the script.\n       * @returns {!webdriver.promise.Promise.<T>} A promise that will resolve to\n       * the\n       *    scripts return value.\n       * @template T\n       */\n\n    }, {\n      key: \"executeAsyncScript_\",\n      value: function executeAsyncScript_(script, description) {\n        if (typeof script === 'function') {\n          script = 'return (' + script + ').apply(null, arguments);';\n        }\n\n        for (var _len2 = arguments.length, scriptArgs = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n          scriptArgs[_key2 - 2] = arguments[_key2];\n        }\n\n        return this.driver.schedule(new Command(CommandName.EXECUTE_ASYNC_SCRIPT).setParameter('script', script).setParameter('args', scriptArgs), description);\n      }\n      /**\n       * Instruct webdriver to wait until Angular has finished rendering and has\n       * no outstanding $http or $timeout calls before continuing.\n       * Note that Protractor automatically applies this command before every\n       * WebDriver action.\n       *\n       * @param {string=} opt_description An optional description to be added\n       *     to webdriver logs.\n       * @returns {!webdriver.promise.Promise} A promise that will resolve to the\n       *    scripts return value.\n       */\n\n    }, {\n      key: \"waitForAngular\",\n      value: function waitForAngular(opt_description) {\n        var _this4 = this;\n\n        var description = opt_description ? ' - ' + opt_description : '';\n\n        if (this.ignoreSynchronization) {\n          return this.driver.controlFlow().execute(function () {\n            return true;\n          }, 'Ignore Synchronization Protractor.waitForAngular()');\n        }\n\n        var runWaitForAngularScript = function runWaitForAngularScript() {\n          if (_this4.plugins_.skipAngularStability() || _this4.bpClient) {\n            return _this4.driver.controlFlow().execute(function () {\n              return selenium_webdriver_1.promise.when(null);\n            }, 'bpClient or plugin stability override');\n          } else {\n            // Need to wrap this so that we read rootEl in the control flow, not synchronously.\n            return _this4.angularAppRoot().then(function (rootEl) {\n              return _this4.executeAsyncScript_(clientSideScripts.waitForAngular, 'Protractor.waitForAngular()' + description, rootEl);\n            });\n          }\n        };\n\n        return runWaitForAngularScript().then(function (browserErr) {\n          if (browserErr) {\n            throw new Error('Error while waiting for Protractor to ' + 'sync with the page: ' + JSON.stringify(browserErr));\n          }\n        }).then(function () {\n          return _this4.driver.controlFlow().execute(function () {\n            return _this4.plugins_.waitForPromise(_this4);\n          }, 'Plugins.waitForPromise()').then(function () {\n            return _this4.driver.wait(function () {\n              return _this4.plugins_.waitForCondition(_this4).then(function (results) {\n                return results.reduce(function (x, y) {\n                  return x && y;\n                }, true);\n              });\n            }, _this4.allScriptsTimeout, 'Plugins.waitForCondition()');\n          });\n        }, function (err) {\n          var timeout;\n\n          if (/asynchronous script timeout/.test(err.message)) {\n            // Timeout on Chrome\n            timeout = /-?[\\d\\.]*\\ seconds/.exec(err.message);\n          } else if (/Timed out waiting for async script/.test(err.message)) {\n            // Timeout on Firefox\n            timeout = /-?[\\d\\.]*ms/.exec(err.message);\n          } else if (/Timed out waiting for an asynchronous script/.test(err.message)) {\n            // Timeout on Safari\n            timeout = /-?[\\d\\.]*\\ ms/.exec(err.message);\n          }\n\n          if (timeout) {\n            var errMsg = \"Timed out waiting for asynchronous Angular tasks to finish after \" + \"\".concat(timeout, \". This may be because the current page is not an Angular \") + \"application. Please see the FAQ for more details: \" + \"https://github.com/angular/protractor/blob/master/docs/timeouts.md#waiting-for-angular\";\n\n            if (description.indexOf(' - Locator: ') == 0) {\n              errMsg += '\\nWhile waiting for element with locator' + description;\n            }\n\n            var pendingTimeoutsPromise;\n\n            if (_this4.trackOutstandingTimeouts_) {\n              pendingTimeoutsPromise = _this4.executeScriptWithDescription('return window.NG_PENDING_TIMEOUTS', 'Protractor.waitForAngular() - getting pending timeouts' + description);\n            } else {\n              pendingTimeoutsPromise = selenium_webdriver_1.promise.when({});\n            }\n\n            var pendingHttpsPromise = _this4.executeScriptWithDescription(clientSideScripts.getPendingHttpRequests, 'Protractor.waitForAngular() - getting pending https' + description, _this4.internalRootEl);\n\n            return selenium_webdriver_1.promise.all([pendingTimeoutsPromise, pendingHttpsPromise]).then(function (arr) {\n              var pendingTimeouts = arr[0] || [];\n              var pendingHttps = arr[1] || [];\n              var key,\n                  pendingTasks = [];\n\n              for (key in pendingTimeouts) {\n                if (pendingTimeouts.hasOwnProperty(key)) {\n                  pendingTasks.push(' - $timeout: ' + pendingTimeouts[key]);\n                }\n              }\n\n              for (key in pendingHttps) {\n                pendingTasks.push(' - $http: ' + pendingHttps[key].url);\n              }\n\n              if (pendingTasks.length) {\n                errMsg += '. \\nThe following tasks were pending:\\n';\n                errMsg += pendingTasks.join('\\n');\n              }\n\n              err.message = errMsg;\n              throw err;\n            }, function () {\n              err.message = errMsg;\n              throw err;\n            });\n          } else {\n            throw err;\n          }\n        });\n      }\n      /**\n       * Waits for Angular to finish rendering before searching for elements.\n       * @see webdriver.WebDriver.findElement\n       * @returns {!webdriver.WebElementPromise} A promise that will be resolved to\n       *      the located {@link webdriver.WebElement}.\n       */\n\n    }, {\n      key: \"findElement\",\n      value: function findElement(locator) {\n        return this.element(locator).getWebElement();\n      }\n      /**\n       * Waits for Angular to finish rendering before searching for elements.\n       * @see webdriver.WebDriver.findElements\n       * @returns {!webdriver.promise.Promise} A promise that will be resolved to an\n       *     array of the located {@link webdriver.WebElement}s.\n       */\n\n    }, {\n      key: \"findElements\",\n      value: function findElements(locator) {\n        return this.element.all(locator).getWebElements();\n      }\n      /**\n       * Tests if an element is present on the page.\n       * @see webdriver.WebDriver.isElementPresent\n       * @returns {!webdriver.promise.Promise} A promise that will resolve to whether\n       *     the element is present on the page.\n       */\n\n    }, {\n      key: \"isElementPresent\",\n      value: function isElementPresent(locatorOrElement) {\n        var element;\n\n        if (locatorOrElement instanceof element_1.ElementFinder) {\n          element = locatorOrElement;\n        } else if (locatorOrElement instanceof selenium_webdriver_1.WebElement) {\n          element = element_1.ElementFinder.fromWebElement_(this, locatorOrElement);\n        } else {\n          element = this.element(locatorOrElement);\n        }\n\n        return element.isPresent();\n      }\n      /**\n       * Add a module to load before Angular whenever Protractor.get is called.\n       * Modules will be registered after existing modules already on the page,\n       * so any module registered here will override preexisting modules with the\n       * same name.\n       *\n       * @example\n       * browser.addMockModule('modName', function() {\n       *   angular.module('modName', []).value('foo', 'bar');\n       * });\n       *\n       * @param {!string} name The name of the module to load or override.\n       * @param {!string|Function} script The JavaScript to load the module.\n       *     Note that this will be executed in the browser context, so it cannot\n       *     access variables from outside its scope.\n       * @param {...*} varArgs Any additional arguments will be provided to\n       *     the script and may be referenced using the `arguments` object.\n       */\n\n    }, {\n      key: \"addMockModule\",\n      value: function addMockModule(name, script) {\n        for (var _len3 = arguments.length, moduleArgs = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n          moduleArgs[_key3 - 2] = arguments[_key3];\n        }\n\n        this.mockModules_.push({\n          name: name,\n          script: script,\n          args: moduleArgs\n        });\n      }\n      /**\n       * Clear the list of registered mock modules.\n       */\n\n    }, {\n      key: \"clearMockModules\",\n      value: function clearMockModules() {\n        this.mockModules_ = [];\n        this.addBaseMockModules_();\n      }\n      /**\n       * Remove a registered mock module.\n       *\n       * @example\n       * browser.removeMockModule('modName');\n       *\n       * @param {!string} name The name of the module to remove.\n       */\n\n    }, {\n      key: \"removeMockModule\",\n      value: function removeMockModule(name) {\n        for (var i = 0; i < this.mockModules_.length; ++i) {\n          if (this.mockModules_[i].name == name) {\n            this.mockModules_.splice(i--, 1);\n          }\n        }\n      }\n      /**\n       * Get a list of the current mock modules.\n       *\n       * @returns {Array.<!string|Function>} The list of mock modules.\n       */\n\n    }, {\n      key: \"getRegisteredMockModules\",\n      value: function getRegisteredMockModules() {\n        return this.mockModules_.map(function (module) {\n          return module.script;\n        });\n      }\n    }, {\n      key: \"addBaseMockModules_\",\n      value:\n      /**\n       * Add the base mock modules used for all Protractor tests.\n       *\n       * @private\n       */\n      function addBaseMockModules_() {\n        this.addMockModule('protractorBaseModule_', clientSideScripts.protractorBaseModuleFn, this.trackOutstandingTimeouts_);\n      }\n      /**\n       * @see webdriver.WebDriver.get\n       *\n       * Navigate to the given destination and loads mock modules before\n       * Angular. Assumes that the page being loaded uses Angular.\n       * If you need to access a page which does not have Angular on load, use\n       * the wrapped webdriver directly.\n       *\n       * @example\n       * browser.get('https://angularjs.org/');\n       * expect(browser.getCurrentUrl()).toBe('https://angularjs.org/');\n       *\n       * @param {string} destination Destination URL.\n       * @param {number=} opt_timeout Number of milliseconds to wait for Angular to\n       *     start.\n       */\n\n    }, {\n      key: \"get\",\n      value: function get(destination) {\n        var _this5 = this;\n\n        var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getPageTimeout;\n        destination = this.baseUrl.indexOf('file://') === 0 ? this.baseUrl + destination : url.resolve(this.baseUrl, destination);\n\n        if (this.ignoreSynchronization) {\n          return this.driver.get(destination).then(function () {\n            return _this5.driver.controlFlow().execute(function () {\n              return _this5.plugins_.onPageLoad(_this5);\n            });\n          }).then(function () {\n            return null;\n          });\n        }\n\n        var msg = function msg(str) {\n          return 'Protractor.get(' + destination + ') - ' + str;\n        };\n\n        return this.driver.controlFlow().execute(function () {\n          return selenium_webdriver_1.promise.when(null);\n        }).then(function () {\n          if (_this5.bpClient) {\n            return _this5.driver.controlFlow().execute(function () {\n              return _this5.bpClient.setWaitEnabled(false);\n            });\n          }\n        }).then(function () {\n          // Go to reset url\n          return _this5.driver.get(_this5.resetUrl);\n        }).then(function () {\n          // Set defer label and navigate\n          return _this5.executeScriptWithDescription('window.name = \"' + DEFER_LABEL + '\" + window.name;' + 'window.location.replace(\"' + destination + '\");', msg('reset url'));\n        }).then(function () {\n          // We need to make sure the new url has loaded before\n          // we try to execute any asynchronous scripts.\n          return _this5.driver.wait(function () {\n            return _this5.executeScriptWithDescription('return window.location.href;', msg('get url')).then(function (url) {\n              return url !== _this5.resetUrl;\n            }, function (err) {\n              if (err.code == 13 || err.name === 'JavascriptError') {\n                // Ignore the error, and continue trying. This is\n                // because IE driver sometimes (~1%) will throw an\n                // unknown error from this execution. See\n                // https://github.com/angular/protractor/issues/841\n                // This shouldn't mask errors because it will fail\n                // with the timeout anyway.\n                return false;\n              } else {\n                throw err;\n              }\n            });\n          }, timeout, 'waiting for page to load for ' + timeout + 'ms');\n        }).then(function () {\n          // Run Plugins\n          return _this5.driver.controlFlow().execute(function () {\n            return _this5.plugins_.onPageLoad(_this5);\n          });\n        }).then(function () {\n          // Make sure the page is an Angular page.\n          return _this5.executeAsyncScript_(clientSideScripts.testForAngular, msg('test for angular'), Math.floor(timeout / 1000), _this5.ng12Hybrid).then(function (angularTestResult) {\n            var angularVersion = angularTestResult.ver;\n\n            if (!angularVersion) {\n              var message = angularTestResult.message;\n              logger.error(\"Could not find Angular on page \".concat(destination, \" : \").concat(message));\n              throw new Error(\"Angular could not be found on the page \".concat(destination, \". \") + \"If this is not an Angular application, you may need to turn off waiting for Angular.\\n                          Please see \\n                          https://github.com/angular/protractor/blob/master/docs/timeouts.md#waiting-for-angular-on-page-load\");\n            }\n\n            return angularVersion;\n          }, function (err) {\n            throw new Error('Error while running testForAngular: ' + err.message);\n          });\n        }).then(function (angularVersion) {\n          // Load Angular Mocks\n          if (angularVersion === 1) {\n            // At this point, Angular will pause for us until angular.resumeBootstrap is called.\n            var moduleNames = [];\n            var modulePromise = selenium_webdriver_1.promise.when(null);\n\n            var _iterator = _createForOfIteratorHelper(_this5.mockModules_),\n                _step;\n\n            try {\n              var _loop = function _loop() {\n                var _step$value = _step.value,\n                    name = _step$value.name,\n                    script = _step$value.script,\n                    args = _step$value.args;\n                moduleNames.push(name);\n                var executeScriptArgs = [script, msg('add mock module ' + name)].concat(_toConsumableArray(args));\n                modulePromise = modulePromise.then(function () {\n                  return _this5.executeScriptWithDescription.apply(_this5, executeScriptArgs).then(null, function (err) {\n                    throw new Error('Error while running module script ' + name + ': ' + err.message);\n                  });\n                });\n              };\n\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                _loop();\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            return modulePromise.then(function () {\n              return _this5.executeScriptWithDescription('window.__TESTABILITY__NG1_APP_ROOT_INJECTOR__ = ' + 'angular.resumeBootstrap(arguments[0]);', msg('resume bootstrap'), moduleNames);\n            });\n          } else {\n            // TODO: support mock modules in Angular2. For now, error if someone\n            // has tried to use one.\n            if (_this5.mockModules_.length > 1) {\n              throw 'Trying to load mock modules on an Angular v2+ app is not yet supported.';\n            }\n          }\n        }).then(function () {\n          // Reset bpClient sync\n          if (_this5.bpClient) {\n            return _this5.driver.controlFlow().execute(function () {\n              return _this5.bpClient.setWaitEnabled(!_this5.internalIgnoreSynchronization);\n            });\n          }\n        }).then(function () {\n          // Run Plugins\n          return _this5.driver.controlFlow().execute(function () {\n            return _this5.plugins_.onPageStable(_this5);\n          });\n        }).then(function () {\n          return null;\n        });\n      }\n      /**\n       * @see webdriver.WebDriver.refresh\n       *\n       * Makes a full reload of the current page and loads mock modules before\n       * Angular. Assumes that the page being loaded uses Angular.\n       * If you need to access a page which does not have Angular on load, use\n       * the wrapped webdriver directly.\n       *\n       * @param {number=} opt_timeout Number of milliseconds to wait for Angular to start.\n       */\n\n    }, {\n      key: \"refresh\",\n      value: function refresh(opt_timeout) {\n        var _this6 = this;\n\n        if (this.ignoreSynchronization) {\n          return this.driver.navigate().refresh();\n        }\n\n        return this.executeScriptWithDescription('return window.location.href', 'Protractor.refresh() - getUrl').then(function (href) {\n          return _this6.get(href, opt_timeout);\n        });\n      }\n      /**\n       * Mixin navigation methods back into the navigation object so that\n       * they are invoked as before, i.e. driver.navigate().refresh()\n       */\n\n    }, {\n      key: \"navigate\",\n      value: function navigate() {\n        var nav = this.driver.navigate();\n        ptorMixin(nav, this, 'refresh');\n        return nav;\n      }\n      /**\n       * Browse to another page using in-page navigation.\n       *\n       * @example\n       * browser.get('http://angular.github.io/protractor/#/tutorial');\n       * browser.setLocation('api');\n       * expect(browser.getCurrentUrl())\n       *     .toBe('http://angular.github.io/protractor/#/api');\n       *\n       * @param {string} url In page URL using the same syntax as $location.url()\n       * @returns {!webdriver.promise.Promise} A promise that will resolve once\n       *    page has been changed.\n       */\n\n    }, {\n      key: \"setLocation\",\n      value: function setLocation(url) {\n        var _this7 = this;\n\n        return this.waitForAngular().then(function () {\n          return _this7.angularAppRoot();\n        }).then(function (rootEl) {\n          return _this7.executeScriptWithDescription(clientSideScripts.setLocation, 'Protractor.setLocation()', rootEl, url).then(function (browserErr) {\n            if (browserErr) {\n              throw 'Error while navigating to \\'' + url + '\\' : ' + JSON.stringify(browserErr);\n            }\n          });\n        });\n      }\n      /**\n       * Deprecated, use `browser.getCurrentUrl()` instead.\n       *\n       * Despite its name, this function will generally return `$location.url()`, though in some\n       * cases it will return `$location.absUrl()` instead.  This function is only here for legacy\n       * users, and will probably be removed in Protractor 6.0.\n       *\n       * @deprecated Please use `browser.getCurrentUrl()`\n       * @example\n       * browser.get('http://angular.github.io/protractor/#/api');\n       * expect(browser.getLocationAbsUrl())\n       *     .toBe('http://angular.github.io/protractor/#/api');\n       * @returns {webdriver.promise.Promise<string>} The current absolute url from\n       * AngularJS.\n       */\n\n    }, {\n      key: \"getLocationAbsUrl\",\n      value: function getLocationAbsUrl() {\n        var _this8 = this;\n\n        logger.warn('`browser.getLocationAbsUrl()` is deprecated, please use `browser.getCurrentUrl` instead.');\n        return this.waitForAngular().then(function () {\n          return _this8.angularAppRoot();\n        }).then(function (rootEl) {\n          return _this8.executeScriptWithDescription(clientSideScripts.getLocationAbsUrl, 'Protractor.getLocationAbsUrl()', rootEl);\n        });\n      }\n      /**\n       * Determine if the control flow is enabled.\n       *\n       * @returns true if the control flow is enabled, false otherwise.\n       */\n\n    }, {\n      key: \"controlFlowIsEnabled\",\n      value: function controlFlowIsEnabled() {\n        if (selenium_webdriver_1.promise.USE_PROMISE_MANAGER !== undefined) {\n          return selenium_webdriver_1.promise.USE_PROMISE_MANAGER;\n        } else {\n          // True for old versions of `selenium-webdriver`, probably false in >=5.0.0\n          return !!selenium_webdriver_1.promise.ControlFlow;\n        }\n      }\n    }]);\n\n    return ProtractorBrowser;\n  }(AbstractExtendedWebDriver);\n  /**\n   * @type {ProtractorBy}\n   */\n\n\n  ProtractorBrowser.By = new locators_1.ProtractorBy();\n  return ProtractorBrowser;\n}();\n\nexports.ProtractorBrowser = ProtractorBrowser;","map":null,"metadata":{},"sourceType":"script"}