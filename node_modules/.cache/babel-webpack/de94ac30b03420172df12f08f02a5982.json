{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n'use strict';\n/**\n * Describes an event listener registered on an {@linkplain EventEmitter}.\n */\n\nvar _createForOfIteratorHelper = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\").default;\n\nvar _createClass = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createClass\").default;\n\nvar _classCallCheck = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar Listener =\n/**\n * @param {!Function} fn The actual listener function.\n * @param {(Object|undefined)} scope The object in whose scope to invoke the\n *     listener.\n * @param {boolean} oneshot Whether this listener should only be used once.\n */\nfunction Listener(fn, scope, oneshot) {\n  _classCallCheck(this, Listener);\n\n  this.fn = fn;\n  this.scope = scope;\n  this.oneshot = oneshot;\n};\n/** @type {!WeakMap<!EventEmitter, !Map<string, !Set<!Listener>>>} */\n\n\nvar EVENTS = new WeakMap();\n/**\n * Object that can emit events for others to listen for.\n */\n\nvar EventEmitter = /*#__PURE__*/function () {\n  function EventEmitter() {\n    _classCallCheck(this, EventEmitter);\n  }\n\n  _createClass(EventEmitter, [{\n    key: \"emit\",\n    value:\n    /**\n     * Fires an event and calls all listeners.\n     * @param {string} type The type of event to emit.\n     * @param {...*} var_args Any arguments to pass to each listener.\n     */\n    function emit(type, var_args) {\n      var events = EVENTS.get(this);\n\n      if (!events) {\n        return;\n      }\n\n      var args = Array.prototype.slice.call(arguments, 1);\n      var listeners = events.get(type);\n\n      if (listeners) {\n        var _iterator = _createForOfIteratorHelper(listeners),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var listener = _step.value;\n            listener.fn.apply(listener.scope, args);\n\n            if (listener.oneshot) {\n              listeners.delete(listener);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    }\n    /**\n     * Returns a mutable list of listeners for a specific type of event.\n     * @param {string} type The type of event to retrieve the listeners for.\n     * @return {!Set<!Listener>} The registered listeners for the given event\n     *     type.\n     */\n\n  }, {\n    key: \"listeners\",\n    value: function listeners(type) {\n      var events = EVENTS.get(this);\n\n      if (!events) {\n        events = new Map();\n        EVENTS.set(this, events);\n      }\n\n      var listeners = events.get(type);\n\n      if (!listeners) {\n        listeners = new Set();\n        events.set(type, listeners);\n      }\n\n      return listeners;\n    }\n    /**\n     * Registers a listener.\n     * @param {string} type The type of event to listen for.\n     * @param {!Function} fn The function to invoke when the event is fired.\n     * @param {Object=} opt_self The object in whose scope to invoke the listener.\n     * @param {boolean=} opt_oneshot Whether the listener should b (e removed after\n     *    the first event is fired.\n     * @return {!EventEmitter} A self reference.\n     * @private\n     */\n\n  }, {\n    key: \"addListener_\",\n    value: function addListener_(type, fn, opt_self, opt_oneshot) {\n      var listeners = this.listeners(type);\n\n      var _iterator2 = _createForOfIteratorHelper(listeners),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var listener = _step2.value;\n\n          if (listener.fn === fn) {\n            return this;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      listeners.add(new Listener(fn, opt_self || undefined, !!opt_oneshot));\n      return this;\n    }\n    /**\n     * Registers a listener.\n     * @param {string} type The type of event to listen for.\n     * @param {!Function} fn The function to invoke when the event is fired.\n     * @param {Object=} opt_self The object in whose scope to invoke the listener.\n     * @return {!EventEmitter} A self reference.\n     */\n\n  }, {\n    key: \"addListener\",\n    value: function addListener(type, fn, opt_self) {\n      return this.addListener_(type, fn, opt_self, false);\n    }\n    /**\n     * Registers a one-time listener which will be called only the first time an\n     * event is emitted, after which it will be removed.\n     * @param {string} type The type of event to listen for.\n     * @param {!Function} fn The function to invoke when the event is fired.\n     * @param {Object=} opt_self The object in whose scope to invoke the listener.\n     * @return {!EventEmitter} A self reference.\n     */\n\n  }, {\n    key: \"once\",\n    value: function once(type, fn, opt_self) {\n      return this.addListener_(type, fn, opt_self, true);\n    }\n    /**\n     * An alias for {@link #addListener() addListener()}.\n     * @param {string} type The type of event to listen for.\n     * @param {!Function} fn The function to invoke when the event is fired.\n     * @param {Object=} opt_self The object in whose scope to invoke the listener.\n     * @return {!EventEmitter} A self reference.\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(type, fn, opt_self) {\n      return this.addListener(type, fn, opt_self);\n    }\n    /**\n     * Removes a previously registered event listener.\n     * @param {string} type The type of event to unregister.\n     * @param {!Function} listenerFn The handler function to remove.\n     * @return {!EventEmitter} A self reference.\n     */\n\n  }, {\n    key: \"removeListener\",\n    value: function removeListener(type, listenerFn) {\n      if (typeof type !== 'string' || typeof listenerFn !== 'function') {\n        throw TypeError('invalid args: expected (string, function), got (' + typeof type + ', ' + typeof listenerFn + ')');\n      }\n\n      var events = EVENTS.get(this);\n\n      if (!events) {\n        return this;\n      }\n\n      var listeners = events.get(type);\n\n      if (!listeners) {\n        return this;\n      }\n\n      var match;\n\n      var _iterator3 = _createForOfIteratorHelper(listeners),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var listener = _step3.value;\n\n          if (listener.fn === listenerFn) {\n            match = listener;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      if (match) {\n        listeners.delete(match);\n\n        if (!listeners.size) {\n          events.delete(type);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Removes all listeners for a specific type of event. If no event is\n     * specified, all listeners across all types will be removed.\n     * @param {string=} opt_type The type of event to remove listeners from.\n     * @return {!EventEmitter} A self reference.\n     */\n\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners(opt_type) {\n      var events = EVENTS.get(this);\n\n      if (events) {\n        if (typeof opt_type === 'string') {\n          events.delete(opt_type);\n        } else {\n          EVENTS.delete(this);\n        }\n      }\n\n      return this;\n    }\n  }]);\n\n  return EventEmitter;\n}(); // PUBLIC API\n\n\nmodule.exports = {\n  EventEmitter: EventEmitter,\n  Listener: Listener\n};","map":null,"metadata":{},"sourceType":"script"}