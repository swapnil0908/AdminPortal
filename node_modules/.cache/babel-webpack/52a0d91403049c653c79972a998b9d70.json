{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _createClass = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createClass\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar webdriver_logger_1 = require(\"./webdriver_logger\");\n\nvar angularWaits = require('./client_scripts/wait.js');\n/**\n * A barrier that uses Angular's Testability API to block commands until the application is stable.\n */\n\n\nvar AngularWaitBarrier = /*#__PURE__*/function () {\n  function AngularWaitBarrier(client) {\n    _classCallCheck(this, AngularWaitBarrier);\n\n    this.client = client;\n    this.enabled = true;\n    this.rootSelector = '';\n  }\n  /**\n   * A CSS Selector for a DOM element within your Angular application.\n   * BlockingProxy will attempt to automatically find your application, but it is\n   * necessary to set rootElement in certain cases.\n   *\n   * In Angular 1, BlockingProxy will use the element your app bootstrapped to by\n   * default.  If that doesn't work, it will then search for hooks in `body` or\n   * `ng-app` elements (details here: https://git.io/v1b2r).\n   *\n   * In later versions of Angular, BlockingProxy will try to hook into all angular\n   * apps on the page. Use rootElement to limit the scope of which apps\n   * BlockingProxy waits for and searches within.\n   *\n   * @param rootSelector A selector for the root element of the Angular app.\n   */\n\n\n  _createClass(AngularWaitBarrier, [{\n    key: \"setRootSelector\",\n    value: function setRootSelector(selector) {\n      this.rootSelector = selector;\n    }\n  }, {\n    key: \"waitForAngularData\",\n    value: function waitForAngularData() {\n      return JSON.stringify({\n        script: 'return (' + angularWaits.NG_WAIT_FN + ').apply(null, arguments);',\n        args: [this.rootSelector]\n      });\n    }\n    /**\n     * Turn on WebDriver logging.\n     *\n     * @param logDir The directory to create logs in.\n     */\n\n  }, {\n    key: \"enableLogging\",\n    value: function enableLogging(logDir) {\n      if (!this.logger) {\n        this.logger = new webdriver_logger_1.WebDriverLogger();\n      }\n\n      this.logger.setLogDir(logDir);\n    }\n    /**\n     * Override the logger instance. Only used for testing.\n     */\n\n  }, {\n    key: \"setLogger\",\n    value: function setLogger(logger) {\n      this.logger = logger;\n    }\n  }, {\n    key: \"sendRequestToStabilize\",\n    value: function sendRequestToStabilize(command) {\n      return this.client.executeAsync(command.sessionId, this.waitForAngularData()).then(function (value) {\n        // waitForAngular only returns a value if there was an error\n        // in the browser.\n        if (value) {\n          throw new Error('Error from waitForAngular: ' + value);\n        }\n      });\n    }\n  }, {\n    key: \"shouldStabilize\",\n    value: function shouldStabilize(command) {\n      var url = command.url;\n\n      if (!this.enabled) {\n        return false;\n      } // TODO - should this implement some state, and be smart about whether\n      // stabilization is necessary or not? Would that be as simple as GET/POST?\n      // e.g. two gets in a row don't require a wait btwn.\n      //\n      // See https://code.google.com/p/selenium/wiki/JsonWireProtocol for\n      // descriptions of the paths.\n      // We shouldn't stabilize if we haven't loaded the page yet.\n\n\n      var parts = url.split('/');\n\n      if (parts.length < 4) {\n        return false;\n      }\n\n      var commandsToWaitFor = ['executeScript', 'screenshot', 'source', 'title', 'element', 'elements', 'execute', 'keys', 'moveto', 'click', 'buttondown', 'buttonup', 'doubleclick', 'touch', 'get'];\n\n      if (commandsToWaitFor.indexOf(parts[3]) != -1) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"onCommand\",\n    value: function onCommand(command) {\n      var _this = this;\n\n      if (this.logger) {\n        command.on('data', function () {\n          _this.logger.logWebDriverCommand(command);\n        });\n      }\n\n      if (this.shouldStabilize(command)) {\n        var started = Date.now();\n        return this.sendRequestToStabilize(command).then(function () {\n          var ended = Date.now();\n\n          if (_this.logger) {\n            _this.logger.logEvent('Waiting for Angular', command.sessionId, ended - started);\n          }\n        });\n      }\n\n      return Promise.resolve(null);\n    }\n  }]);\n\n  return AngularWaitBarrier;\n}();\n\nexports.AngularWaitBarrier = AngularWaitBarrier; //# sourceMappingURL=angular_wait_barrier.js.map","map":null,"metadata":{},"sourceType":"script"}