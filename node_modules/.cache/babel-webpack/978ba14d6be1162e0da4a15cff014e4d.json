{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\").default;\n\nvar _classCallCheck = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _createClass = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createClass\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar q = require(\"q\");\n\nvar webdriver = require(\"selenium-webdriver\");\n\nvar configParser_1 = require(\"./configParser\");\n\nvar logger_1 = require(\"./logger\");\n\nvar ptor_1 = require(\"./ptor\");\n\nvar logger = new logger_1.Logger('plugins');\n\nvar PromiseType = exports.PromiseType = /*@__PURE__*/function (PromiseType) {\n  PromiseType[PromiseType[\"Q\"] = 0] = \"Q\";\n  PromiseType[PromiseType[\"WEBDRIVER\"] = 1] = \"WEBDRIVER\";\n  return PromiseType;\n}(exports.PromiseType || {});\n/**\n * The plugin API for Protractor.  Note that this API is unstable. See\n * plugins/README.md for more information.\n *\n * @constructor\n * @param {Object} config parsed from the config file\n */\n\n\nvar Plugins = /*#__PURE__*/function () {\n  function Plugins(config) {\n    var _this = this;\n\n    _classCallCheck(this, Plugins);\n\n    /**\n     * @see docs/plugins.md#writing-plugins for information on these functions\n     */\n    this.setup = this.pluginFunFactory('setup', PromiseType.Q);\n    this.onPrepare = this.pluginFunFactory('onPrepare', PromiseType.Q);\n    this.teardown = this.pluginFunFactory('teardown', PromiseType.Q);\n    this.postResults = this.pluginFunFactory('postResults', PromiseType.Q);\n    this.postTest = this.pluginFunFactory('postTest', PromiseType.Q);\n    this.onPageLoad = this.pluginFunFactory('onPageLoad', PromiseType.WEBDRIVER);\n    this.onPageStable = this.pluginFunFactory('onPageStable', PromiseType.WEBDRIVER);\n    this.waitForPromise = this.pluginFunFactory('waitForPromise', PromiseType.WEBDRIVER);\n    this.waitForCondition = this.pluginFunFactory('waitForCondition', PromiseType.WEBDRIVER, true);\n    this.pluginObjs = [];\n    this.assertions = {};\n    this.resultsReported = false;\n\n    if (config.plugins) {\n      config.plugins.forEach(function (pluginConf, i) {\n        var path;\n\n        if (pluginConf.path) {\n          path = configParser_1.ConfigParser.resolveFilePatterns(pluginConf.path, true, config.configDir)[0];\n\n          if (!path) {\n            throw new Error('Invalid path to plugin: ' + pluginConf.path);\n          }\n        } else {\n          path = pluginConf.package;\n        }\n\n        var pluginObj;\n\n        if (path) {\n          pluginObj = require(path);\n        } else if (pluginConf.inline) {\n          pluginObj = pluginConf.inline;\n        } else {\n          throw new Error('Plugin configuration did not contain a valid path or ' + 'inline definition.');\n        }\n\n        _this.annotatePluginObj(pluginObj, pluginConf, i);\n\n        logger.debug('Plugin \"' + pluginObj.name + '\" loaded.');\n\n        _this.pluginObjs.push(pluginObj);\n      });\n    }\n  }\n\n  _createClass(Plugins, [{\n    key: \"annotatePluginObj\",\n    value:\n    /**\n     * Adds properties to a plugin's object\n     *\n     * @see docs/plugins.md#provided-properties-and-functions\n     */\n    function annotatePluginObj(obj, conf, i) {\n      var _this2 = this;\n\n      var addAssertion = function addAssertion(info, passed, message) {\n        if (_this2.resultsReported) {\n          throw new Error('Cannot add new tests results, since they were already ' + 'reported.');\n        }\n\n        info = info || {};\n        var specName = info.specName || obj.name + ' Plugin Tests';\n        var assertion = {\n          passed: passed\n        };\n\n        if (!passed) {\n          assertion.errorMsg = message;\n\n          if (info.stackTrace) {\n            assertion.stackTrace = info.stackTrace;\n          }\n        }\n\n        _this2.assertions[specName] = _this2.assertions[specName] || [];\n\n        _this2.assertions[specName].push(assertion);\n      };\n\n      obj.name = obj.name || conf.name || conf.path || conf.package || 'Plugin #' + i;\n      obj.config = conf;\n\n      obj.addFailure = function (message, info) {\n        addAssertion(info, false, message);\n      };\n\n      obj.addSuccess = function (options) {\n        addAssertion(options, true);\n      };\n\n      obj.addWarning = function (message, options) {\n        options = options || {};\n        logger.warn('Warning ' + (options.specName ? 'in ' + options.specName : 'from \"' + obj.name + '\" plugin') + ': ' + message);\n      };\n    }\n  }, {\n    key: \"printPluginResults\",\n    value: function printPluginResults(specResults) {\n      var green = '\\x1b[32m';\n      var red = '\\x1b[31m';\n      var normalColor = '\\x1b[39m';\n\n      var printResult = function printResult(message, pass) {\n        logger.info(pass ? green : red, '\\t', pass ? 'Pass: ' : 'Fail: ', message, normalColor);\n      };\n\n      var _iterator = _createForOfIteratorHelper(specResults),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var specResult = _step.value;\n          var passed = specResult.assertions.map(function (x) {\n            return x.passed;\n          }).reduce(function (x, y) {\n            return x && y;\n          }, true);\n          printResult(specResult.description, passed);\n\n          if (!passed) {\n            var _iterator2 = _createForOfIteratorHelper(specResult.assertions),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var assertion = _step2.value;\n\n                if (!assertion.passed) {\n                  logger.error('\\t\\t' + assertion.errorMsg);\n\n                  if (assertion.stackTrace) {\n                    logger.error('\\t\\t' + assertion.stackTrace.replace(/\\n/g, '\\n\\t\\t'));\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Gets the tests results generated by any plugins\n     *\n     * @see lib/frameworks/README.md#requirements for a complete description of what\n     *     the results object must look like\n     *\n     * @return {Object} The results object\n     */\n\n  }, {\n    key: \"getResults\",\n    value: function getResults() {\n      var results = {\n        failedCount: 0,\n        specResults: []\n      };\n\n      for (var specName in this.assertions) {\n        results.specResults.push({\n          description: specName,\n          assertions: this.assertions[specName]\n        });\n        results.failedCount += this.assertions[specName].filter(function (assertion) {\n          return !assertion.passed;\n        }).length;\n      }\n\n      this.printPluginResults(results.specResults);\n      this.resultsReported = true;\n      return results;\n    }\n  }, {\n    key: \"skipAngularStability\",\n    value:\n    /**\n     * Returns true if any loaded plugin has skipAngularStability enabled.\n     *\n     * @return {boolean}\n     */\n    function skipAngularStability() {\n      var result = this.pluginObjs.some(function (pluginObj) {\n        return pluginObj.skipAngularStability;\n      });\n      return result;\n    }\n  }, {\n    key: \"safeCallPluginFun\",\n    value:\n    /**\n     * Calls a function from a plugin safely.  If the plugin's function throws an\n     * exception or returns a rejected promise, that failure will be logged as a\n     * failed test result instead of crashing protractor.  If the tests results have\n     * already been reported, the failure will be logged to the console.\n     *\n     * @param {Object} pluginObj The plugin object containing the function to be run\n     * @param {string} funName The name of the function we want to run\n     * @param {*[]} args The arguments we want to invoke the function with\n     * @param {PromiseType} promiseType The type of promise (WebDriver or Q) that\n     *    should be used\n     * @param {boolean} resultsReported If the results have already been reported\n     * @param {*} failReturnVal The value to return if the function fails\n     *\n     * @return {webdriver.promise.Promise|Q.Promise} A promise which resolves to the\n     *     function's return value\n     */\n    function safeCallPluginFun(pluginObj, funName, args, promiseType, failReturnVal) {\n      var _this3 = this;\n\n      var resolver = function resolver(done) {\n        var logError = function logError(e) {\n          if (_this3.resultsReported) {\n            _this3.printPluginResults([{\n              description: pluginObj.name + ' Runtime',\n              assertions: [{\n                passed: false,\n                errorMsg: 'Failure during ' + funName + ': ' + (e.message || e),\n                stackTrace: e.stack\n              }]\n            }]);\n          } else {\n            pluginObj.addFailure('Failure during ' + funName + ': ' + e.message || e, {\n              stackTrace: e.stack\n            });\n          }\n\n          done(failReturnVal);\n        };\n\n        try {\n          var result = pluginObj[funName].apply(pluginObj, args);\n\n          if (webdriver.promise.isPromise(result)) {\n            result.then(done, logError);\n          } else {\n            done(result);\n          }\n        } catch (e) {\n          logError(e);\n        }\n      };\n\n      if (promiseType == PromiseType.Q) {\n        return q.Promise(resolver);\n      } else if (ptor_1.protractor.browser.controlFlowIsEnabled()) {\n        return new webdriver.promise.Promise(resolver);\n      } else {\n        return new Promise(resolver);\n      }\n    }\n  }, {\n    key: \"pluginFunFactory\",\n    value: function pluginFunFactory(funName, promiseType, failReturnVal) {\n      var _this4 = this;\n\n      return function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var promises = _this4.pluginObjs.filter(function (pluginObj) {\n          return typeof pluginObj[funName] === 'function';\n        }).map(function (pluginObj) {\n          return _this4.safeCallPluginFun(pluginObj, funName, args, promiseType, failReturnVal);\n        });\n\n        return promiseType == PromiseType.Q ? q.all(promises) : webdriver.promise.all(promises);\n      };\n    }\n  }]);\n\n  return Plugins;\n}();\n\nexports.Plugins = Plugins;","map":null,"metadata":{},"sourceType":"script"}