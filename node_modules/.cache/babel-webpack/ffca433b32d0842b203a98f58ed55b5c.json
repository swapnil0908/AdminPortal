{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _createClass = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createClass\").default;\n\nvar _inherits = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/inherits\").default;\n\nvar _createSuper = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createSuper\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar q = require(\"q\");\n\nvar selenium_webdriver_1 = require(\"selenium-webdriver\");\n\nvar util = require(\"util\");\n\nvar browser_1 = require(\"./browser\");\n\nvar driverProviders_1 = require(\"./driverProviders\");\n\nvar logger_1 = require(\"./logger\");\n\nvar plugins_1 = require(\"./plugins\");\n\nvar ptor_1 = require(\"./ptor\");\n\nvar helper = require(\"./util\");\n\nvar logger = new logger_1.Logger('runner');\n/*\n * Runner is responsible for starting the execution of a test run and triggering\n * setup, teardown, managing config, etc through its various dependencies.\n *\n * The Protractor Runner is a node EventEmitter with the following events:\n * - testPass\n * - testFail\n * - testsDone\n *\n * @param {Object} config\n * @constructor\n */\n\nvar Runner = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(Runner, _events_1$EventEmitte);\n\n  var _super = _createSuper(Runner);\n\n  function Runner(config) {\n    var _this;\n\n    _classCallCheck(this, Runner);\n\n    _this = _super.call(this);\n    /**\n     * Responsible for cleaning up test run and exiting the process.\n     * @private\n     * @param {int} Standard unix exit code\n     */\n\n    _this.exit_ = function (exitCode) {\n      return helper.runFilenameOrFn_(this.config_.configDir, this.config_.onCleanUp, [exitCode]).then(function (returned) {\n        if (typeof returned === 'number') {\n          return returned;\n        } else {\n          return exitCode;\n        }\n      });\n    };\n\n    _this.config_ = config;\n\n    if (config.v8Debug) {\n      // Call this private function instead of sending SIGUSR1 because Windows.\n      process['_debugProcess'](process.pid);\n    }\n\n    if (config.nodeDebug) {\n      process['_debugProcess'](process.pid);\n      var flow = selenium_webdriver_1.promise.controlFlow();\n      _this.ready_ = flow.execute(function () {\n        var nodedebug = require('child_process').fork('debug', ['localhost:5858']);\n\n        process.on('exit', function () {\n          nodedebug.kill('SIGTERM');\n        });\n        nodedebug.on('exit', function () {\n          process.exit(1);\n        });\n      }, 'start the node debugger').then(function () {\n        return flow.timeout(1000, 'waiting for debugger to attach');\n      });\n    }\n\n    if (config.capabilities && config.capabilities.seleniumAddress) {\n      config.seleniumAddress = config.capabilities.seleniumAddress;\n    }\n\n    _this.loadDriverProvider_(config);\n\n    _this.setTestPreparer(config.onPrepare);\n\n    return _this;\n  }\n  /**\n   * Registrar for testPreparers - executed right before tests run.\n   * @public\n   * @param {string/Fn} filenameOrFn\n   */\n\n\n  _createClass(Runner, [{\n    key: \"setTestPreparer\",\n    value: function setTestPreparer(filenameOrFn) {\n      this.preparer_ = filenameOrFn;\n    }\n    /**\n     * Executor of testPreparer\n     * @public\n     * @param {string[]=} An optional list of command line arguments the framework will accept.\n     * @return {q.Promise} A promise that will resolve when the test preparers\n     *     are finished.\n     */\n\n  }, {\n    key: \"runTestPreparer\",\n    value: function runTestPreparer(extraFlags) {\n      var _this2 = this;\n\n      var unknownFlags = this.config_.unknownFlags_ || [];\n\n      if (extraFlags) {\n        unknownFlags = unknownFlags.filter(function (f) {\n          return extraFlags.indexOf(f) === -1;\n        });\n      }\n\n      if (unknownFlags.length > 0 && !this.config_.disableChecks) {\n        // TODO: Make this throw a ConfigError in Protractor 6.\n        logger.warn('Ignoring unknown extra flags: ' + unknownFlags.join(', ') + '. This will be' + ' an error in future versions, please use --disableChecks flag to disable the ' + ' Protractor CLI flag checks. ');\n      }\n\n      return this.plugins_.onPrepare().then(function () {\n        return helper.runFilenameOrFn_(_this2.config_.configDir, _this2.preparer_);\n      });\n    }\n    /**\n     * Called after each test finishes.\n     *\n     * Responsible for `restartBrowserBetweenTests`\n     *\n     * @public\n     * @return {q.Promise} A promise that will resolve when the work here is done\n     */\n\n  }, {\n    key: \"afterEach\",\n    value: function afterEach() {\n      var ret;\n      this.frameworkUsesAfterEach = true;\n\n      if (this.config_.restartBrowserBetweenTests) {\n        this.restartPromise = this.restartPromise || q(ptor_1.protractor.browser.restart());\n        ret = this.restartPromise;\n        this.restartPromise = undefined;\n      }\n\n      return ret || q();\n    }\n    /**\n     * Grab driver provider based on type\n     * @private\n     *\n     * Priority\n     * 1) if directConnect is true, use that\n     * 2) if seleniumAddress is given, use that\n     * 3) if a Sauce Labs account is given, use that\n     * 4) if a seleniumServerJar is specified, use that\n     * 5) try to find the seleniumServerJar in protractor/selenium\n     */\n\n  }, {\n    key: \"loadDriverProvider_\",\n    value: function loadDriverProvider_(config) {\n      this.config_ = config;\n      this.driverprovider_ = driverProviders_1.buildDriverProvider(this.config_);\n    }\n    /**\n     * Getter for the Runner config object\n     * @public\n     * @return {Object} config\n     */\n\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      return this.config_;\n    }\n    /**\n     * Get the control flow used by this runner.\n     * @return {Object} WebDriver control flow.\n     */\n\n  }, {\n    key: \"controlFlow\",\n    value: function controlFlow() {\n      return selenium_webdriver_1.promise.controlFlow();\n    }\n    /**\n     * Sets up convenience globals for test specs\n     * @private\n     */\n\n  }, {\n    key: \"setupGlobals_\",\n    value: function setupGlobals_(browser_) {\n      // Keep $, $$, element, and by/By under the global protractor namespace\n      ptor_1.protractor.browser = browser_;\n      ptor_1.protractor.$ = browser_.$;\n      ptor_1.protractor.$$ = browser_.$$;\n      ptor_1.protractor.element = browser_.element;\n      ptor_1.protractor.by = ptor_1.protractor.By = browser_1.ProtractorBrowser.By;\n      ptor_1.protractor.ExpectedConditions = browser_.ExpectedConditions;\n\n      if (!this.config_.noGlobals) {\n        // Export protractor to the global namespace to be used in tests.\n        global.browser = browser_;\n        global.$ = browser_.$;\n        global.$$ = browser_.$$;\n        global.element = browser_.element;\n        global.by = global.By = ptor_1.protractor.By;\n        global.ExpectedConditions = ptor_1.protractor.ExpectedConditions;\n      }\n\n      global.protractor = ptor_1.protractor;\n\n      if (!this.config_.skipSourceMapSupport) {\n        // Enable sourcemap support for stack traces.\n        require('source-map-support').install();\n      } // Required by dart2js machinery.\n      // https://code.google.com/p/dart/source/browse/branches/bleeding_edge/dart/sdk/lib/js/dart2js/js_dart2js.dart?spec=svn32943&r=32943#487\n\n\n      global.DartObject = function (o) {\n        this.o = o;\n      };\n    }\n    /**\n     * Create a new driver from a driverProvider. Then set up a\n     * new protractor instance using this driver.\n     * This is used to set up the initial protractor instances and any\n     * future ones.\n     *\n     * @param {Plugin} plugins The plugin functions\n     * @param {ProtractorBrowser=} parentBrowser The browser which spawned this one\n     *\n     * @return {Protractor} a protractor instance.\n     * @public\n     */\n\n  }, {\n    key: \"createBrowser\",\n    value: function createBrowser(plugins, parentBrowser) {\n      var _this3 = this;\n\n      var config = this.config_;\n      var driver = this.driverprovider_.getNewDriver();\n      var blockingProxyUrl;\n\n      if (config.useBlockingProxy) {\n        blockingProxyUrl = this.driverprovider_.getBPUrl();\n      }\n\n      var initProperties = {\n        baseUrl: config.baseUrl,\n        rootElement: config.rootElement,\n        untrackOutstandingTimeouts: config.untrackOutstandingTimeouts,\n        params: config.params,\n        getPageTimeout: config.getPageTimeout,\n        allScriptsTimeout: config.allScriptsTimeout,\n        debuggerServerPort: config.debuggerServerPort,\n        ng12Hybrid: config.ng12Hybrid,\n        waitForAngularEnabled: true\n      };\n\n      if (parentBrowser) {\n        initProperties.baseUrl = parentBrowser.baseUrl;\n        initProperties.rootElement = parentBrowser.angularAppRoot();\n        initProperties.untrackOutstandingTimeouts = !parentBrowser.trackOutstandingTimeouts_;\n        initProperties.params = parentBrowser.params;\n        initProperties.getPageTimeout = parentBrowser.getPageTimeout;\n        initProperties.allScriptsTimeout = parentBrowser.allScriptsTimeout;\n        initProperties.debuggerServerPort = parentBrowser.debuggerServerPort;\n        initProperties.ng12Hybrid = parentBrowser.ng12Hybrid;\n        initProperties.waitForAngularEnabled = parentBrowser.waitForAngularEnabled();\n      }\n\n      var browser_ = new browser_1.ProtractorBrowser(driver, initProperties.baseUrl, initProperties.rootElement, initProperties.untrackOutstandingTimeouts, blockingProxyUrl);\n      browser_.params = initProperties.params;\n      browser_.plugins_ = plugins || new plugins_1.Plugins({});\n\n      if (initProperties.getPageTimeout) {\n        browser_.getPageTimeout = initProperties.getPageTimeout;\n      }\n\n      if (initProperties.allScriptsTimeout) {\n        browser_.allScriptsTimeout = initProperties.allScriptsTimeout;\n      }\n\n      if (initProperties.debuggerServerPort) {\n        browser_.debuggerServerPort = initProperties.debuggerServerPort;\n      }\n\n      if (initProperties.ng12Hybrid) {\n        browser_.ng12Hybrid = initProperties.ng12Hybrid;\n      }\n\n      browser_.ready = browser_.ready.then(function () {\n        return browser_.waitForAngularEnabled(initProperties.waitForAngularEnabled);\n      }).then(function () {\n        return driver.manage().timeouts().setScriptTimeout(initProperties.allScriptsTimeout || 0);\n      }).then(function () {\n        return browser_;\n      });\n\n      browser_.getProcessedConfig = function () {\n        return selenium_webdriver_1.promise.when(config);\n      };\n\n      browser_.forkNewDriverInstance = function (useSameUrl, copyMockModules) {\n        var copyConfigUpdates = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n        var newBrowser = _this3.createBrowser(plugins);\n\n        if (copyMockModules) {\n          newBrowser.mockModules_ = browser_.mockModules_;\n        }\n\n        if (useSameUrl) {\n          newBrowser.ready = newBrowser.ready.then(function () {\n            return browser_.driver.getCurrentUrl();\n          }).then(function (url) {\n            return newBrowser.get(url);\n          }).then(function () {\n            return newBrowser;\n          });\n        }\n\n        return newBrowser;\n      };\n\n      var replaceBrowser = function replaceBrowser() {\n        var newBrowser = browser_.forkNewDriverInstance(false, true);\n\n        if (browser_ === ptor_1.protractor.browser) {\n          _this3.setupGlobals_(newBrowser);\n        }\n\n        return newBrowser;\n      };\n\n      browser_.restart = function () {\n        // Note: because tests are not paused at this point, any async\n        // calls here are not guaranteed to complete before the tests resume.\n        // Seperate solutions depending on if the control flow is enabled (see lib/browser.ts)\n        if (browser_.controlFlowIsEnabled()) {\n          return browser_.restartSync().ready;\n        } else {\n          return _this3.driverprovider_.quitDriver(browser_.driver).then(replaceBrowser).then(function (newBrowser) {\n            return newBrowser.ready;\n          });\n        }\n      };\n\n      browser_.restartSync = function () {\n        if (!browser_.controlFlowIsEnabled()) {\n          throw TypeError('Unable to use `browser.restartSync()` when the control flow is disabled');\n        }\n\n        _this3.driverprovider_.quitDriver(browser_.driver);\n\n        return replaceBrowser();\n      };\n\n      return browser_;\n    }\n    /**\n     * Final cleanup on exiting the runner.\n     *\n     * @return {q.Promise} A promise which resolves on finish.\n     * @private\n     */\n\n  }, {\n    key: \"shutdown_\",\n    value: function shutdown_() {\n      return driverProviders_1.DriverProvider.quitDrivers(this.driverprovider_, this.driverprovider_.getExistingDrivers());\n    }\n    /**\n     * The primary workhorse interface. Kicks off the test running process.\n     *\n     * @return {q.Promise} A promise which resolves to the exit code of the tests.\n     * @public\n     */\n\n  }, {\n    key: \"run\",\n    value: function run() {\n      var _this4 = this;\n\n      var testPassed;\n      var plugins = this.plugins_ = new plugins_1.Plugins(this.config_);\n      var pluginPostTestPromises;\n      var browser_;\n      var results;\n\n      if (this.config_.framework !== 'explorer' && !this.config_.specs.length) {\n        throw new Error('Spec patterns did not match any files.');\n      }\n\n      if (this.config_.SELENIUM_PROMISE_MANAGER != null) {\n        selenium_webdriver_1.promise.USE_PROMISE_MANAGER = this.config_.SELENIUM_PROMISE_MANAGER;\n      }\n\n      if (this.config_.webDriverLogDir || this.config_.highlightDelay) {\n        this.config_.useBlockingProxy = true;\n      } // 0) Wait for debugger\n\n\n      return q(this.ready_).then(function () {\n        // 1) Setup environment\n        // noinspection JSValidateTypes\n        return _this4.driverprovider_.setupEnv();\n      }).then(function () {\n        // 2) Create a browser and setup globals\n        browser_ = _this4.createBrowser(plugins);\n\n        _this4.setupGlobals_(browser_);\n\n        return browser_.ready.then(browser_.getSession).then(function (session) {\n          logger.debug('WebDriver session successfully started with capabilities ' + util.inspect(session.getCapabilities()));\n        }, function (err) {\n          logger.error('Unable to start a WebDriver session.');\n          throw err;\n        }); // 3) Setup plugins\n      }).then(function () {\n        return plugins.setup(); // 4) Execute test cases\n      }).then(function () {\n        // Do the framework setup here so that jasmine and mocha globals are\n        // available to the onPrepare function.\n        var frameworkPath = '';\n\n        if (_this4.config_.framework === 'jasmine' || _this4.config_.framework === 'jasmine2') {\n          frameworkPath = './frameworks/jasmine.js';\n        } else if (_this4.config_.framework === 'mocha') {\n          frameworkPath = './frameworks/mocha.js';\n        } else if (_this4.config_.framework === 'debugprint') {\n          // Private framework. Do not use.\n          frameworkPath = './frameworks/debugprint.js';\n        } else if (_this4.config_.framework === 'explorer') {\n          // Private framework. Do not use.\n          frameworkPath = './frameworks/explorer.js';\n        } else if (_this4.config_.framework === 'custom') {\n          if (!_this4.config_.frameworkPath) {\n            throw new Error('When config.framework is custom, ' + 'config.frameworkPath is required.');\n          }\n\n          frameworkPath = _this4.config_.frameworkPath;\n        } else {\n          throw new Error('config.framework (' + _this4.config_.framework + ') is not a valid framework.');\n        }\n\n        if (_this4.config_.restartBrowserBetweenTests) {\n          // TODO(sjelin): replace with warnings once `afterEach` support is required\n          var restartDriver = function restartDriver() {\n            if (!_this4.frameworkUsesAfterEach) {\n              _this4.restartPromise = q(browser_.restart());\n            }\n          };\n\n          _this4.on('testPass', restartDriver);\n\n          _this4.on('testFail', restartDriver);\n        } // We need to save these promises to make sure they're run, but we\n        // don't\n        // want to delay starting the next test (because we can't, it's just\n        // an event emitter).\n\n\n        pluginPostTestPromises = [];\n\n        _this4.on('testPass', function (testInfo) {\n          pluginPostTestPromises.push(plugins.postTest(true, testInfo));\n        });\n\n        _this4.on('testFail', function (testInfo) {\n          pluginPostTestPromises.push(plugins.postTest(false, testInfo));\n        });\n\n        logger.debug('Running with spec files ' + _this4.config_.specs);\n        return require(frameworkPath).run(_this4, _this4.config_.specs); // 5) Wait for postTest plugins to finish\n      }).then(function (testResults) {\n        results = testResults;\n        return q.all(pluginPostTestPromises); // 6) Teardown plugins\n      }).then(function () {\n        return plugins.teardown(); // 7) Teardown\n      }).then(function () {\n        results = helper.joinTestLogs(results, plugins.getResults());\n\n        _this4.emit('testsDone', results);\n\n        testPassed = results.failedCount === 0;\n\n        if (_this4.driverprovider_.updateJob) {\n          return _this4.driverprovider_.updateJob({\n            'passed': testPassed\n          }).then(function () {\n            return _this4.driverprovider_.teardownEnv();\n          });\n        } else {\n          return _this4.driverprovider_.teardownEnv();\n        } // 8) Let plugins do final cleanup\n\n      }).then(function () {\n        return plugins.postResults(); // 9) Exit process\n      }).then(function () {\n        var exitCode = testPassed ? 0 : 1;\n        return _this4.exit_(exitCode);\n      }).fin(function () {\n        return _this4.shutdown_();\n      });\n    }\n  }]);\n\n  return Runner;\n}(events_1.EventEmitter);\n\nexports.Runner = Runner; //# sourceMappingURL=runner.js.map","map":null,"metadata":{},"sourceType":"script"}