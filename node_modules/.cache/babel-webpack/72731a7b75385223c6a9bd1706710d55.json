{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/slicedToArray\").default;\n\nvar _createClass = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createClass\").default;\n\nvar _inherits = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/inherits\").default;\n\nvar _createSuper = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createSuper\").default;\n\nvar _classCallCheck = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar selenium_webdriver_1 = require(\"selenium-webdriver\");\n\nvar locators_1 = require(\"./locators\");\n\nvar logger_1 = require(\"./logger\");\n\nvar util_1 = require(\"./util\");\n\nvar clientSideScripts = require('./clientsidescripts');\n\nvar logger = new logger_1.Logger('element');\n\nvar WebdriverWebElement = function WebdriverWebElement() {\n  _classCallCheck(this, WebdriverWebElement);\n};\n\nexports.WebdriverWebElement = WebdriverWebElement;\nvar WEB_ELEMENT_FUNCTIONS = ['click', 'sendKeys', 'getTagName', 'getCssValue', 'getAttribute', 'getText', 'getSize', 'getLocation', 'isEnabled', 'isSelected', 'submit', 'clear', 'isDisplayed', 'getId', 'takeScreenshot'];\n/**\n * ElementArrayFinder is used for operations on an array of elements (as opposed\n * to a single element).\n *\n * The ElementArrayFinder is used to set up a chain of conditions that identify\n * an array of elements. In particular, you can call all(locator) and\n * filter(filterFn) to return a new ElementArrayFinder modified by the\n * conditions, and you can call get(index) to return a single ElementFinder at\n * position 'index'.\n *\n * Similar to jquery, ElementArrayFinder will search all branches of the DOM\n * to find the elements that satisfy the conditions (i.e. all, filter, get).\n * However, an ElementArrayFinder will not actually retrieve the elements until\n * an action is called, which means it can be set up in helper files (i.e.\n * page objects) before the page is available, and reused as the page changes.\n *\n * You can treat an ElementArrayFinder as an array of WebElements for most\n * purposes, in particular, you may perform actions (i.e. click, getText) on\n * them as you would an array of WebElements. The action will apply to\n * every element identified by the ElementArrayFinder. ElementArrayFinder\n * extends Promise, and once an action is performed on an ElementArrayFinder,\n * the latest result can be accessed using then, and will be returned as an\n * array of the results; the array has length equal to the length of the\n * elements found by the ElementArrayFinder and each result represents the\n * result of performing the action on the element. Unlike a WebElement, an\n * ElementArrayFinder will wait for the angular app to settle before\n * performing finds or actions.\n *\n * @alias element.all(locator)\n * @view\n * <ul class=\"items\">\n *   <li>First</li>\n *   <li>Second</li>\n *   <li>Third</li>\n * </ul>\n *\n * @example\n * element.all(by.css('.items li')).then(function(items) {\n *   expect(items.length).toBe(3);\n *   expect(items[0].getText()).toBe('First');\n * });\n *\n * // Or using the shortcut $$() notation instead of element.all(by.css()):\n *\n * $$('.items li').then(function(items) {\n *   expect(items.length).toBe(3);\n *   expect(items[0].getText()).toBe('First');\n * });\n *\n * @constructor\n * @param {ProtractorBrowser} browser A browser instance.\n * @param {function(): Array.<webdriver.WebElement>} getWebElements A function\n *    that returns a list of the underlying Web Elements.\n * @param {webdriver.Locator} locator The most relevant locator. It is only\n *    used for error reporting and ElementArrayFinder.locator.\n * @param {Array.<webdriver.promise.Promise>} opt_actionResults An array\n *    of promises which will be retrieved with then. Resolves to the latest\n *    action result, or null if no action has been called.\n * @returns {ElementArrayFinder}\n */\n\nvar ElementArrayFinder = /*#__PURE__*/function (_WebdriverWebElement) {\n  _inherits(ElementArrayFinder, _WebdriverWebElement);\n\n  var _super = _createSuper(ElementArrayFinder);\n\n  function ElementArrayFinder(browser_) {\n    var _this;\n\n    var getWebElements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var locator_ = arguments.length > 2 ? arguments[2] : undefined;\n    var actionResults_ = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    _classCallCheck(this, ElementArrayFinder);\n\n    _this = _super.call(this);\n    _this.browser_ = browser_;\n    _this.getWebElements = getWebElements;\n    _this.locator_ = locator_;\n    _this.actionResults_ = actionResults_; // TODO(juliemr): might it be easier to combine this with our docs and just\n    // wrap each one explicity with its own documentation?\n\n    WEB_ELEMENT_FUNCTIONS.forEach(function (fnName) {\n      _this[fnName] = function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var actionFn = function actionFn(webElem) {\n          return webElem[fnName].apply(webElem, args);\n        };\n\n        return _this.applyAction_(actionFn);\n      };\n    });\n    return _this;\n  }\n  /**\n   * Create a shallow copy of ElementArrayFinder.\n   *\n   * @returns {!ElementArrayFinder} A shallow copy of this.\n   */\n\n\n  _createClass(ElementArrayFinder, [{\n    key: \"clone\",\n    value: function clone() {\n      // A shallow copy is all we need since the underlying fields can never be\n      // modified. (Locator can be modified by the user, but that should\n      // rarely/never happen and it doesn't affect functionalities).\n      return new ElementArrayFinder(this.browser_, this.getWebElements, this.locator_, this.actionResults_);\n    }\n    /**\n     * Calls to ElementArrayFinder may be chained to find an array of elements\n     * using the current elements in this ElementArrayFinder as the starting\n     * point. This function returns a new ElementArrayFinder which would contain\n     * the children elements found (and could also be empty).\n     *\n     * @alias element.all(locator).all(locator)\n     * @view\n     * <div id='id1' class=\"parent\">\n     *   <ul>\n     *     <li class=\"foo\">1a</li>\n     *     <li class=\"baz\">1b</li>\n     *   </ul>\n     * </div>\n     * <div id='id2' class=\"parent\">\n     *   <ul>\n     *     <li class=\"foo\">2a</li>\n     *     <li class=\"bar\">2b</li>\n     *   </ul>\n     * </div>\n     *\n     * @example\n     * let foo = element.all(by.css('.parent')).all(by.css('.foo'));\n     * expect(foo.getText()).toEqual(['1a', '2a']);\n     * let baz = element.all(by.css('.parent')).all(by.css('.baz'));\n     * expect(baz.getText()).toEqual(['1b']);\n     * let nonexistent = element.all(by.css('.parent'))\n     *   .all(by.css('.NONEXISTENT'));\n     * expect(nonexistent.getText()).toEqual(['']);\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let foo = $$('.parent').$$('.foo');\n     * expect(foo.getText()).toEqual(['1a', '2a']);\n     * let baz = $$('.parent').$$('.baz');\n     * expect(baz.getText()).toEqual(['1b']);\n     * let nonexistent = $$('.parent').$$('.NONEXISTENT');\n     * expect(nonexistent.getText()).toEqual(['']);\n     *\n     * @param {webdriver.Locator} subLocator\n     * @returns {ElementArrayFinder}\n     */\n\n  }, {\n    key: \"all\",\n    value: function all(locator) {\n      var _this2 = this;\n\n      var ptor = this.browser_;\n\n      var getWebElements = function getWebElements() {\n        if (_this2.getWebElements === null) {\n          // This is the first time we are looking for an element\n          return ptor.waitForAngular('Locator: ' + locator).then(function () {\n            if (locators_1.isProtractorLocator(locator)) {\n              return locator.findElementsOverride(ptor.driver, null, ptor.rootEl);\n            } else {\n              return ptor.driver.findElements(locator);\n            }\n          });\n        } else {\n          return _this2.getWebElements().then(function (parentWebElements) {\n            // For each parent web element, find their children and construct\n            // a list of Promise<List<child_web_element>>\n            var childrenPromiseList = parentWebElements.map(function (parentWebElement) {\n              return locators_1.isProtractorLocator(locator) ? locator.findElementsOverride(ptor.driver, parentWebElement, ptor.rootEl) : parentWebElement.findElements(locator);\n            }); // Resolve the list of Promise<List<child_web_elements>> and merge\n            // into a single list\n\n            return selenium_webdriver_1.promise.all(childrenPromiseList).then(function (resolved) {\n              return resolved.reduce(function (childrenList, resolvedE) {\n                return childrenList.concat(resolvedE);\n              }, []);\n            });\n          });\n        }\n      };\n\n      return new ElementArrayFinder(this.browser_, getWebElements, locator);\n    }\n    /**\n     * Apply a filter function to each element within the ElementArrayFinder.\n     * Returns a new ElementArrayFinder with all elements that pass the filter\n     * function. The filter function receives the ElementFinder as the first\n     * argument and the index as a second arg. This does not actually retrieve\n     * the underlying list of elements, so it can be used in page objects.\n     *\n     * @alias element.all(locator).filter(filterFn)\n     * @view\n     * <ul class=\"items\">\n     *   <li class=\"one\">First</li>\n     *   <li class=\"two\">Second</li>\n     *   <li class=\"three\">Third</li>\n     * </ul>\n     *\n     * @example\n     * element.all(by.css('.items li')).filter(function(elem, index) {\n     *   return elem.getText().then(function(text) {\n     *     return text === 'Third';\n     *   });\n     * }).first().click();\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * $$('.items li').filter(function(elem, index) {\n     *   return elem.getText().then(function(text) {\n     *     return text === 'Third';\n     *   });\n     * }).first().click();\n     *\n     * @param {function(ElementFinder, number): webdriver.WebElement.Promise}\n     * filterFn\n     *     Filter function that will test if an element should be returned.\n     *     filterFn can either return a boolean or a promise that resolves to a\n     * boolean\n     * @returns {!ElementArrayFinder} A ElementArrayFinder that represents an\n     * array\n     *     of element that satisfy the filter function.\n     */\n\n  }, {\n    key: \"filter\",\n    value: function filter(filterFn) {\n      var _this3 = this;\n\n      var getWebElements = function getWebElements() {\n        return _this3.getWebElements().then(function (parentWebElements) {\n          var list = parentWebElements.map(function (parentWebElement, index) {\n            var elementFinder = ElementFinder.fromWebElement_(_this3.browser_, parentWebElement, _this3.locator_);\n            return filterFn(elementFinder, index);\n          });\n          return selenium_webdriver_1.promise.all(list).then(function (resolvedList) {\n            return parentWebElements.filter(function (parentWebElement, index) {\n              return resolvedList[index];\n            });\n          });\n        });\n      };\n\n      return new ElementArrayFinder(this.browser_, getWebElements, this.locator_);\n    }\n    /**\n     * Get an element within the ElementArrayFinder by index. The index starts at 0.\n     * Negative indices are wrapped (i.e. -i means ith element from last)\n     * This does not actually retrieve the underlying element.\n     *\n     * @alias element.all(locator).get(index)\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let list = element.all(by.css('.items li'));\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let list = $$('.items li');\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * @param {number|webdriver.promise.Promise} index Element index.\n     * @returns {ElementFinder} finder representing element at the given index.\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      var _this4 = this;\n\n      var getWebElements = function getWebElements() {\n        return selenium_webdriver_1.promise.all([index, _this4.getWebElements()]).then(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              i = _ref2[0],\n              parentWebElements = _ref2[1];\n\n          if (i < 0) {\n            i += parentWebElements.length;\n          }\n\n          if (i < 0 || i >= parentWebElements.length) {\n            throw new selenium_webdriver_1.error.NoSuchElementError('Index out of bound. Trying to access element at index: ' + index + ', but there are only ' + parentWebElements.length + ' elements that match ' + 'locator ' + _this4.locator_.toString());\n          }\n\n          return [parentWebElements[i]];\n        });\n      };\n\n      return new ElementArrayFinder(this.browser_, getWebElements, this.locator_).toElementFinder_();\n    }\n    /**\n     * Get the first matching element for the ElementArrayFinder. This does not\n     * actually retrieve the underlying element.\n     *\n     * @alias element.all(locator).first()\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let first = element.all(by.css('.items li')).first();\n     * expect(first.getText()).toBe('First');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let first = $$('.items li').first();\n     * expect(first.getText()).toBe('First');\n     *\n     * @returns {ElementFinder} finder representing the first matching element\n     */\n\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.get(0);\n    }\n  }, {\n    key: \"last\",\n    value:\n    /**\n     * Get the last matching element for the ElementArrayFinder. This does not\n     * actually retrieve the underlying element.\n     *\n     * @alias element.all(locator).last()\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let last = element.all(by.css('.items li')).last();\n     * expect(last.getText()).toBe('Third');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let last = $$('.items li').last();\n     * expect(last.getText()).toBe('Third');\n     *\n     * @returns {ElementFinder} finder representing the last matching element\n     */\n    function last() {\n      return this.get(-1);\n    }\n    /**\n     * Shorthand function for finding arrays of elements by css.\n     * `element.all(by.css('.abc'))` is equivalent to `$$('.abc')`\n     *\n     * @alias $$(cssSelector)\n     * @view\n     * <div class=\"count\">\n     *   <span class=\"one\">First</span>\n     *   <span class=\"two\">Second</span>\n     * </div>\n     *\n     * @example\n     * // The following two blocks of code are equivalent.\n     * let list = element.all(by.css('.count span'));\n     * expect(list.count()).toBe(2);\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let list = $$('.count span');\n     * expect(list.count()).toBe(2);\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * @param {string} selector a css selector\n     * @returns {ElementArrayFinder} which identifies the\n     *     array of the located {@link webdriver.WebElement}s.\n     */\n\n  }, {\n    key: \"$$\",\n    value: function $$(selector) {\n      return this.all(selenium_webdriver_1.By.css(selector));\n    }\n    /**\n     * Returns an ElementFinder representation of ElementArrayFinder. It ensures\n     * that the ElementArrayFinder resolves to one and only one underlying\n     * element.\n     *\n     * @returns {ElementFinder} An ElementFinder representation\n     * @private\n     */\n\n  }, {\n    key: \"toElementFinder_\",\n    value: function toElementFinder_() {\n      return new ElementFinder(this.browser_, this);\n    }\n    /**\n     * Count the number of elements represented by the ElementArrayFinder.\n     *\n     * @alias element.all(locator).count()\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let list = element.all(by.css('.items li'));\n     * expect(list.count()).toBe(3);\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let list = $$('.items li');\n     * expect(list.count()).toBe(3);\n     *\n     * @returns {!webdriver.promise.Promise} A promise which resolves to the\n     *     number of elements matching the locator.\n     */\n\n  }, {\n    key: \"count\",\n    value: function count() {\n      return this.getWebElements().then(function (arr) {\n        return arr.length;\n      }, function (err) {\n        if (err instanceof selenium_webdriver_1.error.NoSuchElementError) {\n          return 0;\n        } else {\n          throw err;\n        }\n      });\n    }\n    /**\n     * Returns true if there are any elements present that match the finder.\n     *\n     * @alias element.all(locator).isPresent()\n     *\n     * @example\n     * expect($('.item').isPresent()).toBeTruthy();\n     *\n     * @returns {Promise<boolean>}\n     */\n\n  }, {\n    key: \"isPresent\",\n    value: function isPresent() {\n      return this.count().then(function (count) {\n        return count > 0;\n      });\n    }\n    /**\n     * Returns the most relevant locator.\n     *\n     * @example\n     * // returns by.css('#ID1')\n     * $('#ID1').locator();\n     *\n     * // returns by.css('#ID2')\n     * $('#ID1').$('#ID2').locator();\n     *\n     * // returns by.css('#ID1')\n     * $$('#ID1').filter(filterFn).get(0).click().locator();\n     *\n     * @returns {webdriver.Locator}\n     */\n\n  }, {\n    key: \"locator\",\n    value: function locator() {\n      return this.locator_;\n    }\n    /**\n     * Apply an action function to every element in the ElementArrayFinder,\n     * and return a new ElementArrayFinder that contains the results of the\n     * actions.\n     *\n     * @param {function(ElementFinder)} actionFn\n     *\n     * @returns {ElementArrayFinder}\n     * @private\n     */\n    // map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];\n\n  }, {\n    key: \"applyAction_\",\n    value: function applyAction_(actionFn) {\n      var _this5 = this;\n\n      var callerError = new Error();\n      var actionResults = this.getWebElements().then(function (arr) {\n        return selenium_webdriver_1.promise.all(arr.map(actionFn));\n      }).then(function (value) {\n        return {\n          passed: true,\n          value: value\n        };\n      }, function (error) {\n        return {\n          passed: false,\n          value: error\n        };\n      });\n\n      var getWebElements = function getWebElements() {\n        return actionResults.then(function () {\n          return _this5.getWebElements();\n        });\n      };\n\n      actionResults = actionResults.then(function (result) {\n        if (result.passed) {\n          return result.value;\n        } else {\n          var noSuchErr;\n\n          if (result.value instanceof Error) {\n            noSuchErr = result.value;\n            noSuchErr.stack = noSuchErr.stack + callerError.stack;\n          } else {\n            noSuchErr = new Error(result.value);\n            noSuchErr.stack = callerError.stack;\n          }\n\n          throw noSuchErr;\n        }\n      });\n      return new ElementArrayFinder(this.browser_, getWebElements, this.locator_, actionResults);\n    }\n    /**\n     * Represents the ElementArrayFinder as an array of ElementFinders.\n     *\n     * @returns {Array.<ElementFinder>} Return a promise, which resolves to a list\n     *     of ElementFinders specified by the locator.\n     */\n\n  }, {\n    key: \"asElementFinders_\",\n    value: function asElementFinders_() {\n      var _this6 = this;\n\n      return this.getWebElements().then(function (arr) {\n        return arr.map(function (webElem) {\n          return ElementFinder.fromWebElement_(_this6.browser_, webElem, _this6.locator_);\n        });\n      });\n    }\n    /**\n     * Retrieve the elements represented by the ElementArrayFinder. The input\n     * function is passed to the resulting promise, which resolves to an\n     * array of ElementFinders.\n     *\n     * @alias element.all(locator).then(thenFunction)\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * element.all(by.css('.items li')).then(function(arr) {\n     *   expect(arr.length).toEqual(3);\n     * });\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * $$('.items li').then(function(arr) {\n     *   expect(arr.length).toEqual(3);\n     * });\n     *\n     * @param {function(Array.<ElementFinder>)} fn\n     * @param {function(Error)} errorFn\n     *\n     * @returns {!webdriver.promise.Promise} A promise which will resolve to\n     *     an array of ElementFinders represented by the ElementArrayFinder.\n     */\n\n  }, {\n    key: \"then\",\n    value: function then(fn, errorFn) {\n      if (this.actionResults_) {\n        return this.actionResults_.then(fn, errorFn);\n      } else {\n        return this.asElementFinders_().then(fn, errorFn);\n      }\n    }\n    /**\n     * Calls the input function on each ElementFinder represented by the\n     * ElementArrayFinder.\n     *\n     * @alias element.all(locator).each(eachFunction)\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * element.all(by.css('.items li')).each(function(element, index) {\n     *   // Will print 0 First, 1 Second, 2 Third.\n     *   element.getText().then(function (text) {\n     *     console.log(index, text);\n     *   });\n     * });\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * $$('.items li').each(function(element, index) {\n     *   // Will print 0 First, 1 Second, 2 Third.\n     *   element.getText().then(function (text) {\n     *     console.log(index, text);\n     *   });\n     * });\n     *\n     * @param {function(ElementFinder)} fn Input function\n     *\n     * @returns {!webdriver.promise.Promise} A promise that will resolve when the\n     *     function has been called on all the ElementFinders. The promise will\n     *     resolve to null.\n     */\n\n  }, {\n    key: \"each\",\n    value: function each(fn) {\n      return this.map(fn).then(function () {\n        return null;\n      });\n    }\n    /**\n     * Apply a map function to each element within the ElementArrayFinder. The\n     * callback receives the ElementFinder as the first argument and the index as\n     * a second arg.\n     *\n     * @alias element.all(locator).map(mapFunction)\n     * @view\n     * <ul class=\"items\">\n     *   <li class=\"one\">First</li>\n     *   <li class=\"two\">Second</li>\n     *   <li class=\"three\">Third</li>\n     * </ul>\n     *\n     * @example\n     * let items = element.all(by.css('.items li')).map(function(elm, index) {\n     *   return {\n     *     index: index,\n     *     text: elm.getText(),\n     *     class: elm.getAttribute('class')\n     *   };\n     * });\n     * expect(items).toEqual([\n     *   {index: 0, text: 'First', class: 'one'},\n     *   {index: 1, text: 'Second', class: 'two'},\n     *   {index: 2, text: 'Third', class: 'three'}\n     * ]);\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let items = $$('.items li').map(function(elm, index) {\n     *   return {\n     *     index: index,\n     *     text: elm.getText(),\n     *     class: elm.getAttribute('class')\n     *   };\n     * });\n     * expect(items).toEqual([\n     *   {index: 0, text: 'First', class: 'one'},\n     *   {index: 1, text: 'Second', class: 'two'},\n     *   {index: 2, text: 'Third', class: 'three'}\n     * ]);\n     *\n     * @param {function(ElementFinder, number)} mapFn Map function that\n     *     will be applied to each element.\n     * @returns {!webdriver.promise.Promise} A promise that resolves to an array\n     *     of values returned by the map function.\n     */\n\n  }, {\n    key: \"map\",\n    value: function map(mapFn) {\n      return this.asElementFinders_().then(function (arr) {\n        var list = arr.map(function (elementFinder, index) {\n          var mapResult = mapFn(elementFinder, index); // All nested arrays and objects will also be fully resolved.\n\n          return selenium_webdriver_1.promise.fullyResolved(mapResult);\n        });\n        return selenium_webdriver_1.promise.all(list);\n      });\n    }\n  }, {\n    key: \"reduce\",\n    value:\n    /**\n     * Apply a reduce function against an accumulator and every element found\n     * using the locator (from left-to-right). The reduce function has to reduce\n     * every element into a single value (the accumulator). Returns promise of\n     * the accumulator. The reduce function receives the accumulator, current\n     * ElementFinder, the index, and the entire array of ElementFinders,\n     * respectively.\n     *\n     * @alias element.all(locator).reduce(reduceFn)\n     * @view\n     * <ul class=\"items\">\n     *   <li class=\"one\">First</li>\n     *   <li class=\"two\">Second</li>\n     *   <li class=\"three\">Third</li>\n     * </ul>\n     *\n     * @example\n     * let value = element.all(by.css('.items li')).reduce(function(acc, elem) {\n     *   return elem.getText().then(function(text) {\n     *     return acc + text + ' ';\n     *   });\n     * }, '');\n     *\n     * expect(value).toEqual('First Second Third ');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let value = $$('.items li').reduce(function(acc, elem) {\n     *   return elem.getText().then(function(text) {\n     *     return acc + text + ' ';\n     *   });\n     * }, '');\n     *\n     * expect(value).toEqual('First Second Third ');\n     *\n     * @param {function(number, ElementFinder, number, Array.<ElementFinder>)}\n     *     reduceFn Reduce function that reduces every element into a single\n     * value.\n     * @param {*} initialValue Initial value of the accumulator.\n     * @returns {!webdriver.promise.Promise} A promise that resolves to the final\n     *     value of the accumulator.\n     */\n    function reduce(reduceFn, initialValue) {\n      var valuePromise = selenium_webdriver_1.promise.when(initialValue);\n      return this.asElementFinders_().then(function (arr) {\n        return arr.reduce(function (valuePromise, elementFinder, index) {\n          return valuePromise.then(function (value) {\n            return reduceFn(value, elementFinder, index, arr);\n          });\n        }, valuePromise);\n      });\n    }\n    /**\n     * Evaluates the input as if it were on the scope of the current underlying\n     * elements.\n     *\n     * @view\n     * <span class=\"foo\">{{letiableInScope}}</span>\n     *\n     * @example\n     * let value = element.all(by.css('.foo')).evaluate('letiableInScope');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let value = $$('.foo').evaluate('letiableInScope');\n     *\n     * @param {string} expression\n     *\n     * @returns {ElementArrayFinder} which resolves to the\n     *     evaluated expression for each underlying element.\n     *     The result will be resolved as in\n     *     {@link webdriver.WebDriver.executeScript}. In summary - primitives will\n     *     be resolved as is, functions will be converted to string, and elements\n     *     will be returned as a WebElement.\n     */\n\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(expression) {\n      var evaluationFn = function evaluationFn(webElem) {\n        return webElem.getDriver().executeScript(clientSideScripts.evaluate, webElem, expression);\n      };\n\n      return this.applyAction_(evaluationFn);\n    }\n    /**\n     * Determine if animation is allowed on the current underlying elements.\n     * @param {string} value\n     *\n     * @example\n     * // Turns off ng-animate animations for all elements in the <body>\n     * element(by.css('body')).allowAnimations(false);\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * $('body').allowAnimations(false);\n     *\n     * @returns {ElementArrayFinder} which resolves to whether animation is\n     * allowed.\n     */\n\n  }, {\n    key: \"allowAnimations\",\n    value: function allowAnimations(value) {\n      var allowAnimationsTestFn = function allowAnimationsTestFn(webElem) {\n        return webElem.getDriver().executeScript(clientSideScripts.allowAnimations, webElem, value);\n      };\n\n      return this.applyAction_(allowAnimationsTestFn);\n    }\n  }]);\n\n  return ElementArrayFinder;\n}(WebdriverWebElement);\n\nexports.ElementArrayFinder = ElementArrayFinder;\n/**\n * The ElementFinder simply represents a single element of an\n * ElementArrayFinder (and is more like a convenience object). As a result,\n * anything that can be done with an ElementFinder, can also be done using\n * an ElementArrayFinder.\n *\n * The ElementFinder can be treated as a WebElement for most purposes, in\n * particular, you may perform actions (i.e. click, getText) on them as you\n * would a WebElement. Once an action is performed on an ElementFinder, the\n * latest result from the chain can be accessed using the then method.\n * Unlike a WebElement, an ElementFinder will wait for angular to settle before\n * performing finds or actions.\n *\n * ElementFinder can be used to build a chain of locators that is used to find\n * an element. An ElementFinder does not actually attempt to find the element\n * until an action is called, which means they can be set up in helper files\n * before the page is available.\n *\n * @alias element(locator)\n * @view\n * <span>{{person.name}}</span>\n * <span ng-bind=\"person.email\"></span>\n * <input type=\"text\" ng-model=\"person.name\"/>\n *\n * @example\n * // Find element with {{scopelet}} syntax.\n * element(by.binding('person.name')).getText().then(function(name) {\n *   expect(name).toBe('Foo');\n * });\n *\n * // Find element with ng-bind=\"scopelet\" syntax.\n * expect(element(by.binding('person.email')).getText()).toBe('foo@bar.com');\n *\n * // Find by model.\n * let input = element(by.model('person.name'));\n * input.sendKeys('123');\n * expect(input.getAttribute('value')).toBe('Foo123');\n *\n * @constructor\n * @extends {webdriver.WebElement}\n * @param {ProtractorBrowser} browser_ A browser instance.\n * @param {ElementArrayFinder} elementArrayFinder The ElementArrayFinder\n *     that this is branched from.\n * @returns {ElementFinder}\n */\n\nvar ElementFinder = /*#__PURE__*/function (_WebdriverWebElement2) {\n  _inherits(ElementFinder, _WebdriverWebElement2);\n\n  var _super2 = _createSuper(ElementFinder);\n\n  function ElementFinder(browser_, elementArrayFinder) {\n    var _this7;\n\n    _classCallCheck(this, ElementFinder);\n\n    _this7 = _super2.call(this);\n    _this7.browser_ = browser_;\n    _this7.then = null;\n\n    if (!elementArrayFinder) {\n      throw new Error('BUG: elementArrayFinder cannot be empty');\n    }\n\n    _this7.parentElementArrayFinder = elementArrayFinder; // Only have a `then` method if the parent element array finder\n    // has action results.\n\n    if (_this7.parentElementArrayFinder.actionResults_) {\n      // Access the underlying actionResult of ElementFinder.\n      _this7.then = function (fn, errorFn) {\n        return _this7.elementArrayFinder_.then(function (actionResults) {\n          if (!fn) {\n            return actionResults[0];\n          }\n\n          return fn(actionResults[0]);\n        }, errorFn);\n      };\n    } // This filter verifies that there is only 1 element returned by the\n    // elementArrayFinder. It will warn if there are more than 1 element and\n    // throw an error if there are no elements.\n\n\n    var getWebElements = function getWebElements() {\n      return elementArrayFinder.getWebElements().then(function (webElements) {\n        if (webElements.length === 0) {\n          throw new selenium_webdriver_1.error.NoSuchElementError('No element found using locator: ' + elementArrayFinder.locator().toString());\n        } else {\n          if (webElements.length > 1) {\n            logger.warn('more than one element found for locator ' + elementArrayFinder.locator().toString() + ' - the first result will be used');\n          }\n\n          return [webElements[0]];\n        }\n      });\n    }; // Store a copy of the underlying elementArrayFinder, but with the more\n    // restrictive getWebElements (which checks that there is only 1 element).\n\n\n    _this7.elementArrayFinder_ = new ElementArrayFinder(_this7.browser_, getWebElements, elementArrayFinder.locator(), elementArrayFinder.actionResults_);\n    WEB_ELEMENT_FUNCTIONS.forEach(function (fnName) {\n      _this7[fnName] = function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        return _this7.elementArrayFinder_[fnName].apply(_this7.elementArrayFinder_, args).toElementFinder_();\n      };\n    });\n    return _this7;\n  }\n\n  _createClass(ElementFinder, [{\n    key: \"clone\",\n    value:\n    /**\n     * Create a shallow copy of ElementFinder.\n     *\n     * @returns {!ElementFinder} A shallow copy of this.\n     */\n    function clone() {\n      // A shallow copy is all we need since the underlying fields can never be\n      // modified\n      return new ElementFinder(this.browser_, this.parentElementArrayFinder);\n    }\n    /**\n     * @see ElementArrayFinder.prototype.locator\n     *\n     * @returns {webdriver.Locator}\n     */\n\n  }, {\n    key: \"locator\",\n    value: function locator() {\n      return this.elementArrayFinder_.locator();\n    }\n    /**\n     * Returns the WebElement represented by this ElementFinder.\n     * Throws the WebDriver error if the element doesn't exist.\n     *\n     * @alias element(locator).getWebElement()\n     * @view\n     * <div class=\"parent\">\n     *   some text\n     * </div>\n     *\n     * @example\n     * // The following four expressions are equivalent.\n     * $('.parent').getWebElement();\n     * element(by.css('.parent')).getWebElement();\n     * browser.driver.findElement(by.css('.parent'));\n     * browser.findElement(by.css('.parent'));\n     *\n     * @returns {webdriver.WebElementPromise}\n     */\n\n  }, {\n    key: \"getWebElement\",\n    value: function getWebElement() {\n      var id = this.elementArrayFinder_.getWebElements().then(function (parentWebElements) {\n        return parentWebElements[0];\n      });\n      return new selenium_webdriver_1.WebElementPromise(this.browser_.driver, id);\n    }\n    /**\n     * Calls to {@code all} may be chained to find an array of elements within a\n     * parent.\n     *\n     * @alias element(locator).all(locator)\n     * @view\n     * <div class=\"parent\">\n     *   <ul>\n     *     <li class=\"one\">First</li>\n     *     <li class=\"two\">Second</li>\n     *     <li class=\"three\">Third</li>\n     *   </ul>\n     * </div>\n     *\n     * @example\n     * let items = element(by.css('.parent')).all(by.tagName('li'));\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * let items = $('.parent').all(by.tagName('li'));\n     *\n     * @param {webdriver.Locator} subLocator\n     * @returns {ElementArrayFinder}\n     */\n\n  }, {\n    key: \"all\",\n    value: function all(subLocator) {\n      return this.elementArrayFinder_.all(subLocator);\n    }\n    /**\n     * Calls to {@code element} may be chained to find elements within a parent.\n     *\n     * @alias element(locator).element(locator)\n     * @view\n     * <div class=\"parent\">\n     *   <div class=\"child\">\n     *     Child text\n     *     <div>{{person.phone}}</div>\n     *   </div>\n     * </div>\n     *\n     * @example\n     * // Chain 2 element calls.\n     * let child = element(by.css('.parent')).\n     *     element(by.css('.child'));\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = element(by.css('.parent')).\n     *     element(by.css('.child')).\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * // Chain 2 element calls.\n     * let child = $('.parent').$('.child');\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = $('.parent').$('.child').\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * @param {webdriver.Locator} subLocator\n     * @returns {ElementFinder}\n     */\n\n  }, {\n    key: \"element\",\n    value: function element(subLocator) {\n      return this.all(subLocator).toElementFinder_();\n    }\n    /**\n     * Calls to {@code $$} may be chained to find an array of elements within a\n     * parent.\n     *\n     * @alias element(locator).all(selector)\n     * @view\n     * <div class=\"parent\">\n     *   <ul>\n     *     <li class=\"one\">First</li>\n     *     <li class=\"two\">Second</li>\n     *     <li class=\"three\">Third</li>\n     *   </ul>\n     * </div>\n     *\n     * @example\n     * let items = element(by.css('.parent')).$$('li');\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * let items = $('.parent').$$('li');\n     *\n     * @param {string} selector a css selector\n     * @returns {ElementArrayFinder}\n     */\n\n  }, {\n    key: \"$$\",\n    value: function $$(selector) {\n      return this.all(selenium_webdriver_1.By.css(selector));\n    }\n    /**\n     * Calls to {@code $} may be chained to find elements within a parent.\n     *\n     * @alias element(locator).$(selector)\n     * @view\n     * <div class=\"parent\">\n     *   <div class=\"child\">\n     *     Child text\n     *     <div>{{person.phone}}</div>\n     *   </div>\n     * </div>\n     *\n     * @example\n     * // Chain 2 element calls.\n     * let child = element(by.css('.parent')).\n     *     $('.child');\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = element(by.css('.parent')).\n     *     $('.child').\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * // Chain 2 element calls.\n     * let child = $('.parent').$('.child');\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = $('.parent').$('.child').\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * @param {string} selector A css selector\n     * @returns {ElementFinder}\n     */\n\n  }, {\n    key: \"$\",\n    value: function $(selector) {\n      return this.element(selenium_webdriver_1.By.css(selector));\n    }\n    /**\n     * Determine whether the element is present on the page.\n     *\n     * @view\n     * <span>{{person.name}}</span>\n     *\n     * @example\n     * // Element exists.\n     * expect(element(by.binding('person.name')).isPresent()).toBe(true);\n     *\n     * // Element not present.\n     * expect(element(by.binding('notPresent')).isPresent()).toBe(false);\n     *\n     * @returns {webdriver.promise.Promise<boolean>} which resolves to whether\n     *     the element is present on the page.\n     */\n\n  }, {\n    key: \"isPresent\",\n    value: function isPresent() {\n      return this.parentElementArrayFinder.getWebElements().then(function (arr) {\n        if (arr.length === 0) {\n          return false;\n        }\n\n        return arr[0].isEnabled().then(function () {\n          return true; // is present, whether it is enabled or not\n        }, util_1.falseIfMissing);\n      }, util_1.falseIfMissing);\n    }\n    /**\n     * Same as ElementFinder.isPresent(), except this checks whether the element\n     * identified by the subLocator is present, rather than the current element\n     * finder, i.e.: `element(by.css('#abc')).element(by.css('#def')).isPresent()`\n     * is identical to `element(by.css('#abc')).isElementPresent(by.css('#def'))`.\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * `$('#abc').$('#def').isPresent()` is identical to\n     * `$('#abc').isElementPresent($('#def'))`.\n     *\n     * @see ElementFinder.isPresent\n     *\n     * @param {webdriver.Locator} subLocator Locator for element to look for.\n     * @returns {webdriver.promise.Promise<boolean>} which resolves to whether\n     *     the subelement is present on the page.\n     */\n\n  }, {\n    key: \"isElementPresent\",\n    value: function isElementPresent(subLocator) {\n      if (!subLocator) {\n        throw new Error('SubLocator is not supplied as a parameter to ' + '`isElementPresent(subLocator)`. You are probably looking for the ' + 'function `isPresent()`.');\n      }\n\n      return this.element(subLocator).isPresent();\n    }\n    /**\n     * Evaluates the input as if it were on the scope of the current element.\n     * @see ElementArrayFinder.prototype.evaluate\n     *\n     * @view\n     * <span id=\"foo\">{{letiableInScope}}</span>\n     *\n     * @example\n     * let value = element(by.id('foo')).evaluate('letiableInScope');\n     *\n     * @param {string} expression\n     *\n     * @returns {ElementFinder} which resolves to the evaluated expression.\n     */\n\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(expression) {\n      return this.elementArrayFinder_.evaluate(expression).toElementFinder_();\n    }\n    /**\n     * @see ElementArrayFinder.prototype.allowAnimations.\n     * @param {string} value\n     *\n     * @returns {ElementFinder} which resolves to whether animation is allowed.\n     */\n\n  }, {\n    key: \"allowAnimations\",\n    value: function allowAnimations(value) {\n      return this.elementArrayFinder_.allowAnimations(value).toElementFinder_();\n    }\n    /**\n     * Compares an element to this one for equality.\n     *\n     * @param {!ElementFinder|!webdriver.WebElement} The element to compare to.\n     *\n     * @returns {!webdriver.promise.Promise.<boolean>} A promise that will be\n     *     resolved to whether the two WebElements are equal.\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(element) {\n      return selenium_webdriver_1.WebElement.equals(this.getWebElement(), element.getWebElement ? element.getWebElement() : element);\n    }\n  }], [{\n    key: \"fromWebElement_\",\n    value: function fromWebElement_(browser, webElem, locator) {\n      var getWebElements = function getWebElements() {\n        return selenium_webdriver_1.promise.when([webElem]);\n      };\n\n      return new ElementArrayFinder(browser, getWebElements, locator).toElementFinder_();\n    }\n  }]);\n\n  return ElementFinder;\n}(WebdriverWebElement);\n\nexports.ElementFinder = ElementFinder;\n/**\n * Shortcut for querying the document directly with css.\n * `element(by.css('.abc'))` is equivalent to `$('.abc')`\n *\n * @alias $(cssSelector)\n * @view\n * <div class=\"count\">\n *   <span class=\"one\">First</span>\n *   <span class=\"two\">Second</span>\n * </div>\n *\n * @example\n * let item = $('.count .two');\n * expect(item.getText()).toBe('Second');\n *\n * @param {string} selector A css selector\n * @returns {ElementFinder} which identifies the located\n *     {@link webdriver.WebElement}\n */\n\nexports.build$ = function (element, by) {\n  return function (selector) {\n    return element(by.css(selector));\n  };\n};\n/**\n * Shortcut for querying the document directly with css.\n * `element.all(by.css('.abc'))` is equivalent to `$$('.abc')`\n *\n * @alias $$(cssSelector)\n * @view\n * <div class=\"count\">\n *   <span class=\"one\">First</span>\n *   <span class=\"two\">Second</span>\n * </div>\n *\n * @example\n * // The following protractor expressions are equivalent.\n * let list = element.all(by.css('.count span'));\n * expect(list.count()).toBe(2);\n *\n * list = $$('.count span');\n * expect(list.count()).toBe(2);\n * expect(list.get(0).getText()).toBe('First');\n * expect(list.get(1).getText()).toBe('Second');\n *\n * @param {string} selector a css selector\n * @returns {ElementArrayFinder} which identifies the\n *     array of the located {@link webdriver.WebElement}s.\n */\n\n\nexports.build$$ = function (element, by) {\n  return function (selector) {\n    return element.all(by.css(selector));\n  };\n}; //# sourceMappingURL=element.js.map","map":null,"metadata":{},"sourceType":"script"}