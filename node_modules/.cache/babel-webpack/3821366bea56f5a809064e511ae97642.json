{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines an environment agnostic {@linkplain cmd.Executor\n * command executor} that communicates with a remote end using JSON over HTTP.\n *\n * Clients should implement the {@link Client} interface, which is used by\n * the {@link Executor} to send commands to the remote end.\n */\n'use strict';\n\nvar _inherits = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/inherits\").default;\n\nvar _createSuper = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createSuper\").default;\n\nvar _wrapNativeSuper = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/wrapNativeSuper\").default;\n\nvar _classCallCheck = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _createClass = require(\"/Users/swapnil0908/Downloads/AdminPortal/node_modules/@babel/runtime/helpers/createClass\").default;\n\nvar cmd = require('./command');\n\nvar error = require('./error');\n\nvar logging = require('./logging');\n\nvar promise = require('./promise');\n\nvar Session = require('./session').Session;\n\nvar WebElement = require('./webdriver').WebElement;\n\nvar _ref =\n/** @suppress {undefinedVars|uselessCode} */\nfunction () {\n  try {\n    return {\n      getAttribute: require('./atoms/get-attribute.js'),\n      isDisplayed: require('./atoms/is-displayed.js')\n    };\n  } catch (ex) {\n    throw Error('Failed to import atoms modules. If running in devmode, you need to run' + ' `./go node:atoms` from the project root: ' + ex);\n  }\n}(),\n    getAttribute = _ref.getAttribute,\n    isDisplayed = _ref.isDisplayed;\n/**\n * Converts a headers map to a HTTP header block string.\n * @param {!Map<string, string>} headers The map to convert.\n * @return {string} The headers as a string.\n */\n\n\nfunction headersToString(headers) {\n  var ret = [];\n  headers.forEach(function (value, name) {\n    ret.push(\"\".concat(name.toLowerCase(), \": \").concat(value));\n  });\n  return ret.join('\\n');\n}\n/**\n * Represents a HTTP request message. This class is a \"partial\" request and only\n * defines the path on the server to send a request to. It is each client's\n * responsibility to build the full URL for the final request.\n * @final\n */\n\n\nvar Request = /*#__PURE__*/function () {\n  /**\n   * @param {string} method The HTTP method to use for the request.\n   * @param {string} path The path on the server to send the request to.\n   * @param {Object=} opt_data This request's non-serialized JSON payload data.\n   */\n  function Request(method, path, opt_data) {\n    _classCallCheck(this, Request);\n\n    this.method =\n    /** string */\n    method;\n    this.path =\n    /** string */\n    path;\n    this.data =\n    /** Object */\n    opt_data;\n    this.headers =\n    /** !Map<string, string> */\n    new Map([['Accept', 'application/json; charset=utf-8']]);\n  }\n  /** @override */\n\n\n  _createClass(Request, [{\n    key: \"toString\",\n    value: function toString() {\n      var ret = \"\".concat(this.method, \" \").concat(this.path, \" HTTP/1.1\\n\");\n      ret += headersToString(this.headers) + '\\n\\n';\n\n      if (this.data) {\n        ret += JSON.stringify(this.data);\n      }\n\n      return ret;\n    }\n  }]);\n\n  return Request;\n}();\n/**\n * Represents a HTTP response message.\n * @final\n */\n\n\nvar Response = /*#__PURE__*/function () {\n  /**\n   * @param {number} status The response code.\n   * @param {!Object<string>} headers The response headers. All header names\n   *     will be converted to lowercase strings for consistent lookups.\n   * @param {string} body The response body.\n   */\n  function Response(status, headers, body) {\n    _classCallCheck(this, Response);\n\n    this.status =\n    /** number */\n    status;\n    this.body =\n    /** string */\n    body;\n    this.headers =\n    /** !Map<string, string>*/\n    new Map();\n\n    for (var header in headers) {\n      this.headers.set(header.toLowerCase(), headers[header]);\n    }\n  }\n  /** @override */\n\n\n  _createClass(Response, [{\n    key: \"toString\",\n    value: function toString() {\n      var ret = \"HTTP/1.1 \".concat(this.status, \"\\n\").concat(headersToString(this.headers), \"\\n\\n\");\n\n      if (this.body) {\n        ret += this.body;\n      }\n\n      return ret;\n    }\n  }]);\n\n  return Response;\n}();\n\nvar DEV_ROOT = '../../../../buck-out/gen/javascript/';\n/** @enum {!Function} */\n\nvar Atom = {\n  GET_ATTRIBUTE: getAttribute,\n  IS_DISPLAYED: isDisplayed\n};\nvar LOG = logging.getLogger('webdriver.http');\n\nfunction post(path) {\n  return resource('POST', path);\n}\n\nfunction del(path) {\n  return resource('DELETE', path);\n}\n\nfunction get(path) {\n  return resource('GET', path);\n}\n\nfunction resource(method, path) {\n  return {\n    method: method,\n    path: path\n  };\n}\n/** @typedef {{method: string, path: string}} */\n\n\nvar CommandSpec;\n/** @typedef {function(!cmd.Command): !Promise<!cmd.Command>} */\n\nvar CommandTransformer;\n\nvar InternalTypeError = /*#__PURE__*/function (_TypeError) {\n  _inherits(InternalTypeError, _TypeError);\n\n  var _super = _createSuper(InternalTypeError);\n\n  function InternalTypeError() {\n    _classCallCheck(this, InternalTypeError);\n\n    return _super.apply(this, arguments);\n  }\n\n  return InternalTypeError;\n}( /*#__PURE__*/_wrapNativeSuper(TypeError));\n/**\n * @param {!cmd.Command} command The initial command.\n * @param {Atom} atom The name of the atom to execute.\n * @return {!Promise<!cmd.Command>} The transformed command to execute.\n */\n\n\nfunction toExecuteAtomCommand(command, atom) {\n  for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    params[_key - 2] = arguments[_key];\n  }\n\n  return new Promise(function (resolve, reject) {\n    if (typeof atom !== 'function') {\n      reject(new InternalTypeError('atom is not a function: ' + typeof atom));\n      return;\n    }\n\n    var newCmd = new cmd.Command(cmd.Name.EXECUTE_SCRIPT).setParameter('sessionId', command.getParameter('sessionId')).setParameter('script', \"return (\".concat(atom, \").apply(null, arguments)\")).setParameter('args', params.map(function (param) {\n      return command.getParameter(param);\n    }));\n    resolve(newCmd);\n  });\n}\n/** @const {!Map<string, CommandSpec>} */\n\n\nvar COMMAND_MAP = new Map([[cmd.Name.GET_SERVER_STATUS, get('/status')], [cmd.Name.NEW_SESSION, post('/session')], [cmd.Name.GET_SESSIONS, get('/sessions')], [cmd.Name.DESCRIBE_SESSION, get('/session/:sessionId')], [cmd.Name.QUIT, del('/session/:sessionId')], [cmd.Name.CLOSE, del('/session/:sessionId/window')], [cmd.Name.GET_CURRENT_WINDOW_HANDLE, get('/session/:sessionId/window_handle')], [cmd.Name.GET_WINDOW_HANDLES, get('/session/:sessionId/window_handles')], [cmd.Name.GET_CURRENT_URL, get('/session/:sessionId/url')], [cmd.Name.GET, post('/session/:sessionId/url')], [cmd.Name.GO_BACK, post('/session/:sessionId/back')], [cmd.Name.GO_FORWARD, post('/session/:sessionId/forward')], [cmd.Name.REFRESH, post('/session/:sessionId/refresh')], [cmd.Name.ADD_COOKIE, post('/session/:sessionId/cookie')], [cmd.Name.GET_ALL_COOKIES, get('/session/:sessionId/cookie')], [cmd.Name.DELETE_ALL_COOKIES, del('/session/:sessionId/cookie')], [cmd.Name.DELETE_COOKIE, del('/session/:sessionId/cookie/:name')], [cmd.Name.FIND_ELEMENT, post('/session/:sessionId/element')], [cmd.Name.FIND_ELEMENTS, post('/session/:sessionId/elements')], [cmd.Name.GET_ACTIVE_ELEMENT, post('/session/:sessionId/element/active')], [cmd.Name.FIND_CHILD_ELEMENT, post('/session/:sessionId/element/:id/element')], [cmd.Name.FIND_CHILD_ELEMENTS, post('/session/:sessionId/element/:id/elements')], [cmd.Name.CLEAR_ELEMENT, post('/session/:sessionId/element/:id/clear')], [cmd.Name.CLICK_ELEMENT, post('/session/:sessionId/element/:id/click')], [cmd.Name.SEND_KEYS_TO_ELEMENT, post('/session/:sessionId/element/:id/value')], [cmd.Name.SUBMIT_ELEMENT, post('/session/:sessionId/element/:id/submit')], [cmd.Name.GET_ELEMENT_TEXT, get('/session/:sessionId/element/:id/text')], [cmd.Name.GET_ELEMENT_TAG_NAME, get('/session/:sessionId/element/:id/name')], [cmd.Name.IS_ELEMENT_SELECTED, get('/session/:sessionId/element/:id/selected')], [cmd.Name.IS_ELEMENT_ENABLED, get('/session/:sessionId/element/:id/enabled')], [cmd.Name.IS_ELEMENT_DISPLAYED, get('/session/:sessionId/element/:id/displayed')], [cmd.Name.GET_ELEMENT_LOCATION, get('/session/:sessionId/element/:id/location')], [cmd.Name.GET_ELEMENT_SIZE, get('/session/:sessionId/element/:id/size')], [cmd.Name.GET_ELEMENT_ATTRIBUTE, get('/session/:sessionId/element/:id/attribute/:name')], [cmd.Name.GET_ELEMENT_VALUE_OF_CSS_PROPERTY, get('/session/:sessionId/element/:id/css/:propertyName')], [cmd.Name.ELEMENT_EQUALS, get('/session/:sessionId/element/:id/equals/:other')], [cmd.Name.TAKE_ELEMENT_SCREENSHOT, get('/session/:sessionId/element/:id/screenshot')], [cmd.Name.SWITCH_TO_WINDOW, post('/session/:sessionId/window')], [cmd.Name.MAXIMIZE_WINDOW, post('/session/:sessionId/window/current/maximize')], [cmd.Name.GET_WINDOW_POSITION, get('/session/:sessionId/window/current/position')], [cmd.Name.SET_WINDOW_POSITION, post('/session/:sessionId/window/current/position')], [cmd.Name.GET_WINDOW_SIZE, get('/session/:sessionId/window/current/size')], [cmd.Name.SET_WINDOW_SIZE, post('/session/:sessionId/window/current/size')], [cmd.Name.SWITCH_TO_FRAME, post('/session/:sessionId/frame')], [cmd.Name.GET_PAGE_SOURCE, get('/session/:sessionId/source')], [cmd.Name.GET_TITLE, get('/session/:sessionId/title')], [cmd.Name.EXECUTE_SCRIPT, post('/session/:sessionId/execute')], [cmd.Name.EXECUTE_ASYNC_SCRIPT, post('/session/:sessionId/execute_async')], [cmd.Name.SCREENSHOT, get('/session/:sessionId/screenshot')], [cmd.Name.GET_TIMEOUT, get('/session/:sessionId/timeouts')], [cmd.Name.SET_TIMEOUT, post('/session/:sessionId/timeouts')], [cmd.Name.MOVE_TO, post('/session/:sessionId/moveto')], [cmd.Name.CLICK, post('/session/:sessionId/click')], [cmd.Name.DOUBLE_CLICK, post('/session/:sessionId/doubleclick')], [cmd.Name.MOUSE_DOWN, post('/session/:sessionId/buttondown')], [cmd.Name.MOUSE_UP, post('/session/:sessionId/buttonup')], [cmd.Name.MOVE_TO, post('/session/:sessionId/moveto')], [cmd.Name.SEND_KEYS_TO_ACTIVE_ELEMENT, post('/session/:sessionId/keys')], [cmd.Name.TOUCH_SINGLE_TAP, post('/session/:sessionId/touch/click')], [cmd.Name.TOUCH_DOUBLE_TAP, post('/session/:sessionId/touch/doubleclick')], [cmd.Name.TOUCH_DOWN, post('/session/:sessionId/touch/down')], [cmd.Name.TOUCH_UP, post('/session/:sessionId/touch/up')], [cmd.Name.TOUCH_MOVE, post('/session/:sessionId/touch/move')], [cmd.Name.TOUCH_SCROLL, post('/session/:sessionId/touch/scroll')], [cmd.Name.TOUCH_LONG_PRESS, post('/session/:sessionId/touch/longclick')], [cmd.Name.TOUCH_FLICK, post('/session/:sessionId/touch/flick')], [cmd.Name.ACCEPT_ALERT, post('/session/:sessionId/accept_alert')], [cmd.Name.DISMISS_ALERT, post('/session/:sessionId/dismiss_alert')], [cmd.Name.GET_ALERT_TEXT, get('/session/:sessionId/alert_text')], [cmd.Name.SET_ALERT_TEXT, post('/session/:sessionId/alert_text')], [cmd.Name.SET_ALERT_CREDENTIALS, post('/session/:sessionId/alert/credentials')], [cmd.Name.GET_LOG, post('/session/:sessionId/log')], [cmd.Name.GET_AVAILABLE_LOG_TYPES, get('/session/:sessionId/log/types')], [cmd.Name.GET_SESSION_LOGS, post('/logs')], [cmd.Name.UPLOAD_FILE, post('/session/:sessionId/file')]]);\n/** @const {!Map<string, (CommandSpec|CommandTransformer)>} */\n\nvar W3C_COMMAND_MAP = new Map([[cmd.Name.GET_ACTIVE_ELEMENT, get('/session/:sessionId/element/active')], [cmd.Name.GET_ALERT_TEXT, get('/session/:sessionId/alert/text')], [cmd.Name.SET_ALERT_TEXT, post('/session/:sessionId/alert/text')], [cmd.Name.ACCEPT_ALERT, post('/session/:sessionId/alert/accept')], [cmd.Name.DISMISS_ALERT, post('/session/:sessionId/alert/dismiss')], [cmd.Name.GET_ELEMENT_ATTRIBUTE, function (cmd) {\n  return toExecuteAtomCommand(cmd, Atom.GET_ATTRIBUTE, 'id', 'name');\n}], [cmd.Name.GET_ELEMENT_LOCATION, get('/session/:sessionId/element/:id/rect')], [cmd.Name.GET_ELEMENT_SIZE, get('/session/:sessionId/element/:id/rect')], [cmd.Name.IS_ELEMENT_DISPLAYED, function (cmd) {\n  return toExecuteAtomCommand(cmd, Atom.IS_DISPLAYED, 'id');\n}], [cmd.Name.EXECUTE_SCRIPT, post('/session/:sessionId/execute/sync')], [cmd.Name.EXECUTE_ASYNC_SCRIPT, post('/session/:sessionId/execute/async')], [cmd.Name.MAXIMIZE_WINDOW, post('/session/:sessionId/window/maximize')], [cmd.Name.GET_WINDOW_POSITION, get('/session/:sessionId/window/position')], [cmd.Name.SET_WINDOW_POSITION, post('/session/:sessionId/window/position')], [cmd.Name.GET_WINDOW_SIZE, get('/session/:sessionId/window/size')], [cmd.Name.SET_WINDOW_SIZE, post('/session/:sessionId/window/size')], [cmd.Name.GET_CURRENT_WINDOW_HANDLE, get('/session/:sessionId/window')], [cmd.Name.GET_WINDOW_HANDLES, get('/session/:sessionId/window/handles')]]);\n/**\n * Handles sending HTTP messages to a remote end.\n *\n * @interface\n */\n\nvar Client = /*#__PURE__*/function () {\n  function Client() {\n    _classCallCheck(this, Client);\n  }\n\n  _createClass(Client, [{\n    key: \"send\",\n    value:\n    /**\n     * Sends a request to the server. The client will automatically follow any\n     * redirects returned by the server, fulfilling the returned promise with the\n     * final response.\n     *\n     * @param {!Request} httpRequest The request to send.\n     * @return {!Promise<Response>} A promise that will be fulfilled with the\n     *     server's response.\n     */\n    function send(httpRequest) {}\n  }]);\n\n  return Client;\n}();\n\nvar CLIENTS =\n/** !WeakMap<!Executor, !(Client|IThenable<!Client>)> */\nnew WeakMap();\n/**\n * Sends a request using the given executor.\n * @param {!Executor} executor\n * @param {!Request} request\n * @return {!Promise<Response>}\n */\n\nfunction doSend(executor, request) {\n  var client = CLIENTS.get(executor);\n\n  if (promise.isPromise(client)) {\n    return client.then(function (client) {\n      CLIENTS.set(executor, client);\n      return client.send(request);\n    });\n  } else {\n    return client.send(request);\n  }\n}\n/**\n * @param {Map<string, CommandSpec>} customCommands\n *     A map of custom command definitions.\n * @param {boolean} w3c Whether to use W3C command mappings.\n * @param {!cmd.Command} command The command to resolve.\n * @return {!Promise<!Request>} A promise that will resolve with the\n *     command to execute.\n */\n\n\nfunction buildRequest(customCommands, w3c, command) {\n  LOG.finest(function () {\n    return \"Translating command: \".concat(command.getName());\n  });\n  var spec = customCommands && customCommands.get(command.getName());\n\n  if (spec) {\n    return toHttpRequest(spec);\n  }\n\n  if (w3c) {\n    spec = W3C_COMMAND_MAP.get(command.getName());\n\n    if (typeof spec === 'function') {\n      LOG.finest(function () {\n        return \"Transforming command for W3C: \".concat(command.getName());\n      });\n      return spec(command).then(function (newCommand) {\n        return buildRequest(customCommands, w3c, newCommand);\n      });\n    } else if (spec) {\n      return toHttpRequest(spec);\n    }\n  }\n\n  spec = COMMAND_MAP.get(command.getName());\n\n  if (spec) {\n    return toHttpRequest(spec);\n  }\n\n  return Promise.reject(new error.UnknownCommandError('Unrecognized command: ' + command.getName()));\n  /**\n   * @param {CommandSpec} resource\n   * @return {!Promise<!Request>}\n   */\n\n  function toHttpRequest(resource) {\n    LOG.finest(function () {\n      return \"Building HTTP request: \".concat(JSON.stringify(resource));\n    });\n    var parameters = command.getParameters();\n    var path = buildPath(resource.path, parameters);\n    return Promise.resolve(new Request(resource.method, path, parameters));\n  }\n}\n/**\n * A command executor that communicates with the server using JSON over HTTP.\n *\n * By default, each instance of this class will use the legacy wire protocol\n * from [Selenium project][json]. The executor will automatically switch to the\n * [W3C wire protocol][w3c] if the remote end returns a compliant response to\n * a new session command.\n *\n * [json]: https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol\n * [w3c]: https://w3c.github.io/webdriver/webdriver-spec.html\n *\n * @implements {cmd.Executor}\n */\n\n\nvar Executor = /*#__PURE__*/function () {\n  /**\n   * @param {!(Client|IThenable<!Client>)} client The client to use for sending\n   *     requests to the server, or a promise-like object that will resolve to\n   *     to the client.\n   */\n  function Executor(client) {\n    _classCallCheck(this, Executor);\n\n    CLIENTS.set(this, client);\n    /**\n     * Whether this executor should use the W3C wire protocol. The executor\n     * will automatically switch if the remote end sends a compliant response\n     * to a new session command, however, this property may be directly set to\n     * `true` to force the executor into W3C mode.\n     * @type {boolean}\n     */\n\n    this.w3c = false;\n    /** @private {Map<string, CommandSpec>} */\n\n    this.customCommands_ = null;\n    /** @private {!logging.Logger} */\n\n    this.log_ = logging.getLogger('webdriver.http.Executor');\n  }\n  /**\n   * Defines a new command for use with this executor. When a command is sent,\n   * the {@code path} will be preprocessed using the command's parameters; any\n   * path segments prefixed with \":\" will be replaced by the parameter of the\n   * same name. For example, given \"/person/:name\" and the parameters\n   * \"{name: 'Bob'}\", the final command path will be \"/person/Bob\".\n   *\n   * @param {string} name The command name.\n   * @param {string} method The HTTP method to use when sending this command.\n   * @param {string} path The path to send the command to, relative to\n   *     the WebDriver server's command root and of the form\n   *     \"/path/:variable/segment\".\n   */\n\n\n  _createClass(Executor, [{\n    key: \"defineCommand\",\n    value: function defineCommand(name, method, path) {\n      if (!this.customCommands_) {\n        this.customCommands_ = new Map();\n      }\n\n      this.customCommands_.set(name, {\n        method: method,\n        path: path\n      });\n    }\n    /** @override */\n\n  }, {\n    key: \"execute\",\n    value: function execute(command) {\n      var _this = this;\n\n      var request = buildRequest(this.customCommands_, this.w3c, command);\n      return request.then(function (request) {\n        _this.log_.finer(function () {\n          return \">>> \".concat(request.method, \" \").concat(request.path);\n        });\n\n        return doSend(_this, request).then(function (response) {\n          _this.log_.finer(function () {\n            return \">>>\\n\".concat(request, \"\\n<<<\\n\").concat(response);\n          });\n\n          var httpResponse =\n          /** @type {!Response} */\n          response;\n\n          var _parseHttpResponse = parseHttpResponse(command, httpResponse),\n              isW3C = _parseHttpResponse.isW3C,\n              value = _parseHttpResponse.value;\n\n          if (command.getName() === cmd.Name.NEW_SESSION || command.getName() === cmd.Name.DESCRIBE_SESSION) {\n            if (!value || !value.sessionId) {\n              throw new error.WebDriverError(\"Unable to parse new session response: \".concat(response.body));\n            } // The remote end is a W3C compliant server if there is no `status`\n            // field in the response. This is not applicable for the DESCRIBE_SESSION\n            // command, which is not defined in the W3C spec.\n\n\n            if (command.getName() === cmd.Name.NEW_SESSION) {\n              _this.w3c = _this.w3c || isW3C;\n            } // No implementations use the `capabilities` key yet...\n\n\n            var capabilities = value.capabilities || value.value;\n            return new Session(value.sessionId, capabilities);\n          }\n\n          return typeof value === 'undefined' ? null : value;\n        });\n      });\n    }\n  }]);\n\n  return Executor;\n}();\n/**\n * @param {string} str .\n * @return {?} .\n */\n\n\nfunction tryParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch (ignored) {// Do nothing.\n  }\n}\n/**\n * Callback used to parse {@link Response} objects from a\n * {@link HttpClient}.\n *\n * @param {!cmd.Command} command The command the response is for.\n * @param {!Response} httpResponse The HTTP response to parse.\n * @return {{isW3C: boolean, value: ?}} An object describing the parsed\n *     response. This object will have two fields: `isW3C` indicates whether\n *     the response looks like it came from a remote end that conforms with the\n *     W3C WebDriver spec, and `value`, the actual response value.\n * @throws {WebDriverError} If the HTTP response is an error.\n */\n\n\nfunction parseHttpResponse(command, httpResponse) {\n  if (httpResponse.status < 200) {\n    // This should never happen, but throw the raw response so users report it.\n    throw new error.WebDriverError(\"Unexpected HTTP response:\\n\".concat(httpResponse));\n  }\n\n  var parsed = tryParse(httpResponse.body);\n\n  if (parsed && typeof parsed === 'object') {\n    var _value = parsed.value;\n    var isW3C = _value !== null && typeof _value === 'object' && typeof parsed.status === 'undefined';\n\n    if (!isW3C) {\n      error.checkLegacyResponse(parsed); // Adjust legacy new session responses to look like W3C to simplify\n      // later processing.\n\n      if (command.getName() === cmd.Name.NEW_SESSION || command.getName() == cmd.Name.DESCRIBE_SESSION) {\n        _value = parsed;\n      }\n    } else if (httpResponse.status > 399) {\n      error.throwDecodedError(_value);\n    }\n\n    return {\n      isW3C: isW3C,\n      value: _value\n    };\n  }\n\n  if (parsed !== undefined) {\n    return {\n      isW3C: false,\n      value: parsed\n    };\n  }\n\n  var value = httpResponse.body.replace(/\\r\\n/g, '\\n'); // 404 represents an unknown command; anything else > 399 is a generic unknown\n  // error.\n\n  if (httpResponse.status == 404) {\n    throw new error.UnsupportedOperationError(value);\n  } else if (httpResponse.status >= 400) {\n    throw new error.WebDriverError(value);\n  }\n\n  return {\n    isW3C: false,\n    value: value || null\n  };\n}\n/**\n * Builds a fully qualified path using the given set of command parameters. Each\n * path segment prefixed with ':' will be replaced by the value of the\n * corresponding parameter. All parameters spliced into the path will be\n * removed from the parameter map.\n * @param {string} path The original resource path.\n * @param {!Object<*>} parameters The parameters object to splice into the path.\n * @return {string} The modified path.\n */\n\n\nfunction buildPath(path, parameters) {\n  var pathParameters = path.match(/\\/:(\\w+)\\b/g);\n\n  if (pathParameters) {\n    for (var i = 0; i < pathParameters.length; ++i) {\n      var key = pathParameters[i].substring(2); // Trim the /:\n\n      if (key in parameters) {\n        var value = parameters[key];\n\n        if (WebElement.isId(value)) {\n          // When inserting a WebElement into the URL, only use its ID value,\n          // not the full JSON.\n          value = WebElement.extractId(value);\n        }\n\n        path = path.replace(pathParameters[i], '/' + value);\n        delete parameters[key];\n      } else {\n        throw new error.InvalidArgumentError('Missing required parameter: ' + key);\n      }\n    }\n  }\n\n  return path;\n} // PUBLIC API\n\n\nexports.Executor = Executor;\nexports.Client = Client;\nexports.Request = Request;\nexports.Response = Response;\nexports.buildPath = buildPath; // Exported for testing.","map":null,"metadata":{},"sourceType":"script"}