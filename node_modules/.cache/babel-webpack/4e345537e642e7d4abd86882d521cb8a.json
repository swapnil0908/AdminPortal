{"ast":null,"code":"import _slicedToArray from \"/Users/swapnil0908/Documents/AdminPortal/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"/Users/swapnil0908/Documents/AdminPortal/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/Users/swapnil0908/Documents/AdminPortal/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/swapnil0908/Documents/AdminPortal/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/swapnil0908/Documents/AdminPortal/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _regeneratorRuntime from \"/Users/swapnil0908/Documents/AdminPortal/node_modules/@babel/runtime/regenerator\";\nimport { __awaiter } from 'tslib';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, EventEmitter, Component, ChangeDetectionStrategy, Input, Output, Directive, ViewContainerRef, ComponentFactoryResolver, HostListener, Injector, ApplicationRef, TemplateRef, Host, NgModule } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { CommonModule } from '@angular/common';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nfunction SwalPortalComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0);\n  }\n}\n\nvar swalProviderToken = new InjectionToken('@sweetalert2/ngx-sweetalert2#swalProvider');\nvar fireOnInitToken = new InjectionToken('@sweetalert2/ngx-sweetalert2#fireOnInit');\nvar dismissOnDestroyToken = new InjectionToken('@sweetalert2/ngx-sweetalert2#dismissOnDestroy');\n\nvar SweetAlert2LoaderService = /*@__PURE__*/function () {\n  var SweetAlert2LoaderService = /*#__PURE__*/function () {\n    // Using any because Angular metadata generator does not understand a pure TS type here\n    function SweetAlert2LoaderService(swalProvider) {\n      _classCallCheck(this, SweetAlert2LoaderService);\n\n      this.swalProvider = swalProvider;\n    }\n\n    _createClass(SweetAlert2LoaderService, [{\n      key: \"swal\",\n      get: function get() {\n        if (!this.swalPromiseCache) {\n          this.preloadSweetAlertLibrary();\n        }\n\n        return this.swalPromiseCache;\n      }\n    }, {\n      key: \"preloadSweetAlertLibrary\",\n      value: function preloadSweetAlertLibrary() {\n        if (this.swalPromiseCache) return;\n        var libPromise = isLoader(this.swalProvider) ? this.swalProvider() : Promise.resolve(this.swalProvider);\n        this.swalPromiseCache = libPromise.then(function (value) {\n          return isDefaultExport(value) ? value : value.default;\n        });\n\n        function isLoader(value) {\n          return typeof value === 'function' && value.version === undefined;\n        }\n\n        function isDefaultExport(value) {\n          return typeof value === 'function';\n        }\n      }\n    }]);\n\n    return SweetAlert2LoaderService;\n  }();\n\n  SweetAlert2LoaderService.ɵfac = function SweetAlert2LoaderService_Factory(t) {\n    return new (t || SweetAlert2LoaderService)(ɵngcc0.ɵɵinject(swalProviderToken));\n  };\n\n  SweetAlert2LoaderService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: SweetAlert2LoaderService,\n    factory: SweetAlert2LoaderService.ɵfac\n  });\n  return SweetAlert2LoaderService;\n}();\n\nvar SwalComponent = /*@__PURE__*/function () {\n  var SwalComponent = /*#__PURE__*/function () {\n    function SwalComponent(sweetAlert2Loader, moduleLevelFireOnInit, moduleLevelDismissOnDestroy) {\n      _classCallCheck(this, SwalComponent);\n\n      this.sweetAlert2Loader = sweetAlert2Loader;\n      this.moduleLevelFireOnInit = moduleLevelFireOnInit;\n      this.moduleLevelDismissOnDestroy = moduleLevelDismissOnDestroy;\n      /**\n       * Modal lifecycle hook. Synchronously runs before the modal is shown on screen.\n       */\n\n      this.willOpen = new EventEmitter();\n      /**\n       * Modal lifecycle hook. Synchronously runs before the modal is shown on screen.\n       */\n\n      this.didOpen = new EventEmitter();\n      /**\n       * Modal lifecycle hook. Synchronously runs after the popup DOM has been updated (ie. just before the modal is\n       * repainted on the screen).\n       * Typically, this will happen after `Swal.fire()` or `Swal.update()`.\n       * If you want to perform changes in the popup's DOM, that survive `Swal.update()`, prefer {@link didRender} over\n       * {@link willOpen}.\n       */\n\n      this.didRender = new EventEmitter();\n      /**\n       * Modal lifecycle hook. Synchronously runs when the popup closes by user interaction (and not due to another popup\n       * being fired).\n       */\n\n      this.willClose = new EventEmitter();\n      /**\n       * Modal lifecycle hook. Asynchronously runs after the popup has been disposed by user interaction (and not due to\n       * another popup being fired).\n       */\n\n      this.didClose = new EventEmitter();\n      /**\n       * Modal lifecycle hook. Synchronously runs after popup has been destroyed either by user interaction or by another\n       * popup.\n       * If you have cleanup operations that you need to reliably execute each time a modal is closed, prefer\n       * {@link didDestroy} over {@link didClose}.\n       */\n\n      this.didDestroy = new EventEmitter();\n      /**\n       * Emits when the user clicks \"Confirm\".\n       * The event value ($event) can be either:\n       *  - by default, just `true`,\n       *  - when using {@link input}, the input value,\n       *  - when using {@link preConfirm}, the return value of this function.\n       *\n       * Example:\n       *     <swal (confirm)=\"handleConfirm($event)\"></swal>\n       *\n       *     public handleConfirm(email: string): void {\n       *         // ... save user email\n       *     }\n       */\n\n      this.confirm = new EventEmitter();\n      /**\n       * Emits when the user clicks \"Deny\".\n       * This event bears no value.\n       * Use `(deny)` (along with {@link showDenyButton}) when you want a modal with three buttons (confirm, deny and\n       * cancel), and/or when you want to handle clear refusal in a separate way than simple dismissal.\n       *\n       * Example:\n       *     <swal (deny)=\"handleDeny()\"></swal>\n       *\n       *     public handleDeny(): void {\n       *     }\n       */\n\n      this.deny = new EventEmitter();\n      /**\n       * Emits when the user clicks \"Cancel\", or dismisses the modal by any other allowed way.\n       * The event value ($event) is a string that explains how the modal was dismissed. It is `undefined` when\n       * the modal was programmatically closed (through {@link close} for example).\n       *\n       * Example:\n       *     <swal (dismiss)=\"handleDismiss($event)\"></swal>\n       *\n       *     public handleDismiss(reason: DismissReason | undefined): void {\n       *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.\n       *         // ... do something\n       *     }\n       */\n\n      this.dismiss = new EventEmitter();\n      /**\n       * This Set retains the properties that have been changed from @Inputs, so we can know precisely\n       * what options we have to send to {@link Swal.fire}.\n       */\n\n      this.touchedProps = new Set();\n      /**\n       * A function of signature `(propName: string): void` that adds a given property name to the list of\n       * touched properties, ie. {@link touchedProps}.\n       */\n\n      this.markTouched = this.touchedProps.add.bind(this.touchedProps);\n      /**\n       * Is the SweetAlert2 modal represented by this component currently opened?\n       */\n\n      this.isCurrentlyShown = false;\n    }\n    /**\n     * An object of SweetAlert2 native options, useful if:\n     *  - you don't want to use the @Inputs for practical/philosophical reasons ;\n     *  - there are missing @Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.\n     *\n     * /!\\ Please note that setting this property does NOT erase what has been set before unless you specify the\n     *     previous properties you want to erase again.\n     *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.\n     *\n     * /!\\ Be aware that the options defined in this object will override the @Inputs of the same name.\n     */\n\n\n    _createClass(SwalComponent, [{\n      key: \"swalOptions\",\n      get:\n      /**\n       * Computes the options object that will get passed to SweetAlert2.\n       * Only the properties that have been set at least once on this component will be returned.\n       * Mostly for internal usage.\n       */\n      function get() {\n        var _this = this;\n\n        //=> We will compute the options object based on the option keys that are known to have changed.\n        //   That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially\n        //   avoiding side effects.\n        return _toConsumableArray(this.touchedProps).reduce(function (obj, key) {\n          return Object.assign(Object.assign({}, obj), _defineProperty({}, key, _this[key]));\n        }, {});\n      },\n      set: function set(options) {\n        //=> Update properties\n        Object.assign(this, options); //=> Mark changed properties as touched\n\n        var touchedKeys = Object.keys(options);\n        touchedKeys.forEach(this.markTouched);\n      }\n    }, {\n      key: \"swalVisible\",\n      get: function get() {\n        return this.isCurrentlyShown;\n      }\n      /**\n       * Angular lifecycle hook.\n       * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there\n       * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,\n       * causing no delay.\n       */\n      ,\n      set: function set(visible) {\n        visible ? this.fire() : this.close();\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        //=> Preload SweetAlert2 library in case this component is activated.\n        this.sweetAlert2Loader.preloadSweetAlertLibrary();\n      }\n      /**\n       * Angular lifecycle hook.\n       * Fires the modal, if the component or module is configured to do so.\n       */\n\n    }, {\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        var fireOnInit = this.swalFireOnInit === undefined ? this.moduleLevelFireOnInit : this.swalFireOnInit;\n        fireOnInit && this.fire();\n      }\n      /**\n       * Angular lifecycle hook.\n       * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        //=> For each changed @Input that matches a SweetAlert2 option, mark as touched so we can\n        //   send it with the next fire() or update() calls.\n        Object.keys(changes) //=> If the filtering logic becomes more complex here, we can use Swal.isValidParameter\n        .filter(function (key) {\n          return !key.startsWith('swal');\n        }).forEach(this.markTouched); //=> Eventually trigger re-render if the modal is open.\n\n        void this.update();\n      }\n      /**\n       * Angular lifecycle hook.\n       * Closes the SweetAlert when the component is destroyed.\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        //=> Release the modal if the component is destroyed and if that behaviour is not disabled.\n        var dismissOnDestroy = this.swalDismissOnDestroy === undefined ? this.moduleLevelDismissOnDestroy : this.swalDismissOnDestroy;\n        dismissOnDestroy && this.close();\n      }\n      /**\n       * Shows the SweetAlert.\n       *\n       * Returns the SweetAlert2 promise for convenience and use in code behind templates.\n       * Otherwise, (confirm)=\"myHandler($event)\" and (dismiss)=\"myHandler($event)\" can be used in templates.\n       */\n\n    }, {\n      key: \"fire\",\n      value: function fire() {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          var _this2 = this;\n\n          var swal, userOptions, options, result, composeHook;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  composeHook = function _composeHook(userHook, libHook) {\n                    return function () {\n                      return libHook.apply(void 0, arguments), userHook === null || userHook === void 0 ? void 0 : userHook.apply(void 0, arguments);\n                    };\n                  };\n\n                  _context.next = 3;\n                  return this.sweetAlert2Loader.swal;\n\n                case 3:\n                  swal = _context.sent;\n                  userOptions = this.swalOptions; //=> Build the SweetAlert2 options\n\n                  options = Object.assign(Object.assign({}, userOptions), {\n                    //=> Handle modal lifecycle events\n                    willOpen: composeHook(userOptions.willOpen, function (modalElement) {\n                      _this2.willOpen.emit({\n                        modalElement: modalElement\n                      });\n                    }),\n                    didOpen: composeHook(userOptions.didOpen, function (modalElement) {\n                      _this2.isCurrentlyShown = true;\n\n                      _this2.didOpen.emit({\n                        modalElement: modalElement\n                      });\n                    }),\n                    didRender: composeHook(userOptions.didRender, function (modalElement) {\n                      _this2.didRender.emit({\n                        modalElement: modalElement\n                      });\n                    }),\n                    willClose: composeHook(userOptions.willClose, function (modalElement) {\n                      _this2.isCurrentlyShown = false;\n\n                      _this2.willClose.emit({\n                        modalElement: modalElement\n                      });\n                    }),\n                    didClose: composeHook(userOptions.didClose, function () {\n                      _this2.didClose.emit();\n                    }),\n                    didDestroy: composeHook(userOptions.didDestroy, function () {\n                      _this2.didDestroy.emit();\n                    })\n                  }); //=> Show the Swal! And wait for confirmation or dimissal.\n\n                  _context.next = 8;\n                  return swal.fire(options);\n\n                case 8:\n                  result = _context.sent;\n                  _context.t0 = true;\n                  _context.next = _context.t0 === result.isConfirmed ? 12 : _context.t0 === result.isDenied ? 14 : _context.t0 === result.isDismissed ? 16 : 18;\n                  break;\n\n                case 12:\n                  this.confirm.emit(result.value);\n                  return _context.abrupt(\"break\", 18);\n\n                case 14:\n                  this.deny.emit();\n                  return _context.abrupt(\"break\", 18);\n\n                case 16:\n                  this.dismiss.emit(result.dismiss);\n                  return _context.abrupt(\"break\", 18);\n\n                case 18:\n                  return _context.abrupt(\"return\", result);\n\n                case 19:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n      }\n      /**\n       * Closes the modal, if opened.\n       *\n       * @param result The value that the modal will resolve with, triggering either (confirm), (deny) or (dismiss).\n       *               If the argument is not passed, it is (dismiss) that will emit an `undefined` reason.\n       *               {@see Swal.close}.\n       */\n\n    }, {\n      key: \"close\",\n      value: function close(result) {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n          var swal;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (this.isCurrentlyShown) {\n                    _context2.next = 2;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\");\n\n                case 2:\n                  _context2.next = 4;\n                  return this.sweetAlert2Loader.swal;\n\n                case 4:\n                  swal = _context2.sent;\n                  swal.close(result);\n\n                case 6:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n      }\n      /**\n       * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.\n       * If the modal is not opened, the component options will simply be updated and that's it.\n       *\n       * /!\\ Please note that not all SweetAlert2 options are updatable while the modal is opened.\n       *\n       * @param options\n       */\n\n    }, {\n      key: \"update\",\n      value: function update(options) {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n          var swal, allOptions, updatableOptions;\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  if (options) {\n                    this.swalOptions = options;\n                  }\n\n                  if (this.isCurrentlyShown) {\n                    _context3.next = 3;\n                    break;\n                  }\n\n                  return _context3.abrupt(\"return\");\n\n                case 3:\n                  _context3.next = 5;\n                  return this.sweetAlert2Loader.swal;\n\n                case 5:\n                  swal = _context3.sent;\n                  allOptions = this.swalOptions;\n                  updatableOptions = Object.keys(allOptions).filter(swal.isUpdatableParameter).reduce(function (obj, key) {\n                    return Object.assign(Object.assign({}, obj), _defineProperty({}, key, allOptions[key]));\n                  }, {});\n                  swal.update(updatableOptions);\n\n                case 9:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this);\n        }));\n      }\n    }]);\n\n    return SwalComponent;\n  }();\n\n  SwalComponent.ɵfac = function SwalComponent_Factory(t) {\n    return new (t || SwalComponent)(ɵngcc0.ɵɵdirectiveInject(SweetAlert2LoaderService), ɵngcc0.ɵɵdirectiveInject(fireOnInitToken), ɵngcc0.ɵɵdirectiveInject(dismissOnDestroyToken));\n  };\n\n  SwalComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: SwalComponent,\n    selectors: [[\"swal\"]],\n    inputs: {\n      swalOptions: \"swalOptions\",\n      swalVisible: \"swalVisible\",\n      title: \"title\",\n      titleText: \"titleText\",\n      text: \"text\",\n      html: \"html\",\n      footer: \"footer\",\n      icon: \"icon\",\n      iconColor: \"iconColor\",\n      iconHtml: \"iconHtml\",\n      backdrop: \"backdrop\",\n      toast: \"toast\",\n      target: \"target\",\n      input: \"input\",\n      width: \"width\",\n      padding: \"padding\",\n      background: \"background\",\n      position: \"position\",\n      grow: \"grow\",\n      showClass: \"showClass\",\n      hideClass: \"hideClass\",\n      customClass: \"customClass\",\n      timer: \"timer\",\n      timerProgressBar: \"timerProgressBar\",\n      heightAuto: \"heightAuto\",\n      allowOutsideClick: \"allowOutsideClick\",\n      allowEscapeKey: \"allowEscapeKey\",\n      allowEnterKey: \"allowEnterKey\",\n      stopKeydownPropagation: \"stopKeydownPropagation\",\n      keydownListenerCapture: \"keydownListenerCapture\",\n      showConfirmButton: \"showConfirmButton\",\n      showDenyButton: \"showDenyButton\",\n      showCancelButton: \"showCancelButton\",\n      confirmButtonText: \"confirmButtonText\",\n      denyButtonText: \"denyButtonText\",\n      cancelButtonText: \"cancelButtonText\",\n      confirmButtonColor: \"confirmButtonColor\",\n      denyButtonColor: \"denyButtonColor\",\n      cancelButtonColor: \"cancelButtonColor\",\n      confirmButtonAriaLabel: \"confirmButtonAriaLabel\",\n      denyButtonAriaLabel: \"denyButtonAriaLabel\",\n      cancelButtonAriaLabel: \"cancelButtonAriaLabel\",\n      buttonsStyling: \"buttonsStyling\",\n      reverseButtons: \"reverseButtons\",\n      focusConfirm: \"focusConfirm\",\n      focusDeny: \"focusDeny\",\n      focusCancel: \"focusCancel\",\n      showCloseButton: \"showCloseButton\",\n      closeButtonHtml: \"closeButtonHtml\",\n      closeButtonAriaLabel: \"closeButtonAriaLabel\",\n      loaderHtml: \"loaderHtml\",\n      showLoaderOnConfirm: \"showLoaderOnConfirm\",\n      preConfirm: \"preConfirm\",\n      preDeny: \"preDeny\",\n      imageUrl: \"imageUrl\",\n      imageWidth: \"imageWidth\",\n      imageHeight: \"imageHeight\",\n      imageAlt: \"imageAlt\",\n      inputLabel: \"inputLabel\",\n      inputPlaceholder: \"inputPlaceholder\",\n      inputValue: \"inputValue\",\n      inputOptions: \"inputOptions\",\n      inputAutoTrim: \"inputAutoTrim\",\n      inputAttributes: \"inputAttributes\",\n      inputValidator: \"inputValidator\",\n      returnInputValueOnDeny: \"returnInputValueOnDeny\",\n      validationMessage: \"validationMessage\",\n      progressSteps: \"progressSteps\",\n      currentProgressStep: \"currentProgressStep\",\n      progressStepsDistance: \"progressStepsDistance\",\n      scrollbarPadding: \"scrollbarPadding\",\n      swalFireOnInit: \"swalFireOnInit\",\n      swalDismissOnDestroy: \"swalDismissOnDestroy\"\n    },\n    outputs: {\n      willOpen: \"willOpen\",\n      didOpen: \"didOpen\",\n      didRender: \"didRender\",\n      willClose: \"willClose\",\n      didClose: \"didClose\",\n      didDestroy: \"didDestroy\",\n      confirm: \"confirm\",\n      deny: \"deny\",\n      dismiss: \"dismiss\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function SwalComponent_Template(rf, ctx) {},\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return SwalComponent;\n}();\n\nvar SwalDirective = /*@__PURE__*/function () {\n  var SwalDirective = /*#__PURE__*/function () {\n    function SwalDirective(viewContainerRef, resolver) {\n      _classCallCheck(this, SwalDirective);\n\n      this.viewContainerRef = viewContainerRef;\n      this.resolver = resolver;\n      /**\n       * Emits when the user clicks \"Confirm\".\n       * The event value ($event) can be either:\n       *  - by default, just `true`,\n       *  - when using {@link input}, the input value,\n       *  - when using {@link preConfirm}, the return value of this function.\n       *\n       * Example:\n       *     <swal (confirm)=\"handleConfirm($event)\"></swal>\n       *\n       *     public handleConfirm(email: string): void {\n       *         // ... save user email\n       *     }\n       */\n\n      this.confirm = new EventEmitter();\n      /**\n       * Emits when the user clicks \"Deny\".\n       * This event bears no value.\n       * Use `(deny)` (along with {@link showDenyButton}) when you want a modal with three buttons (confirm, deny and\n       * cancel), and/or when you want to handle clear refusal in a separate way than simple dismissal.\n       *\n       * Example:\n       *     <swal (deny)=\"handleDeny()\"></swal>\n       *\n       *     public handleDeny(): void {\n       *     }\n       */\n\n      this.deny = new EventEmitter();\n      /**\n       * Emits when the user clicks \"Cancel\", or dismisses the modal by any other allowed way.\n       * The event value ($event) is a string that explains how the modal was dismissed. It is `undefined` when\n       * the modal was programmatically closed (through {@link dismiss} for example).\n       *\n       * Example:\n       *     <swal (dismiss)=\"handleDismiss($event)\"></swal>\n       *\n       *     public handleDismiss(reason: DismissReason | undefined): void {\n       *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.\n       *         // ... do something\n       *     }\n       */\n\n      this.dismiss = new EventEmitter();\n    }\n    /**\n     * SweetAlert2 options or a SwalComponent instance.\n     * See the class doc block for more informations.\n     */\n\n\n    _createClass(SwalDirective, [{\n      key: \"swal\",\n      set: function set(options) {\n        if (options instanceof SwalComponent) {\n          this.swalInstance = options;\n        } else if (isArrayOptions(options)) {\n          this.swalOptions = {};\n\n          var _options = _slicedToArray(options, 3);\n\n          this.swalOptions.title = _options[0];\n          this.swalOptions.text = _options[1];\n          this.swalOptions.icon = _options[2];\n        } else {\n          this.swalOptions = options;\n        }\n\n        function isArrayOptions(value) {\n          return Array.isArray(options);\n        }\n      }\n      /**\n       * OnInit lifecycle handler.\n       * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm),\n       * (deny) and (dismiss) outputs to reemit on the directive.\n       */\n\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        if (!this.swalInstance) {\n          var factory = this.resolver.resolveComponentFactory(SwalComponent);\n          this.swalRef = this.viewContainerRef.createComponent(factory);\n          this.swalInstance = this.swalRef.instance;\n        }\n      }\n      /**\n       * OnDestroy lifecycle handler.\n       * Destroys the dynamically-created SwalComponent.\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.swalRef) {\n          this.swalRef.destroy();\n        }\n      }\n      /**\n       * Click handler.\n       * The directive listens for onclick events on its host element.\n       * When this happens, it shows the <swal> attached to this directive.\n       */\n\n    }, {\n      key: \"onClick\",\n      value: function onClick(event) {\n        var _this3 = this;\n\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        event.stopPropagation();\n        if (!this.swalInstance) return;\n\n        if (this.swalOptions) {\n          this.swalInstance.swalOptions = this.swalOptions;\n        }\n\n        var swalClosed = new Subject();\n        this.swalInstance.confirm.asObservable().pipe(takeUntil(swalClosed)).subscribe(function (v) {\n          return _this3.confirm.emit(v);\n        });\n        this.swalInstance.deny.asObservable().pipe(takeUntil(swalClosed)).subscribe(function (v) {\n          return _this3.deny.emit(v);\n        });\n        this.swalInstance.dismiss.asObservable().pipe(takeUntil(swalClosed)).subscribe(function (v) {\n          return _this3.dismiss.emit(v);\n        });\n        this.swalInstance.fire().then(function () {\n          return swalClosed.next();\n        });\n      }\n    }]);\n\n    return SwalDirective;\n  }();\n\n  SwalDirective.ɵfac = function SwalDirective_Factory(t) {\n    return new (t || SwalDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver));\n  };\n\n  SwalDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SwalDirective,\n    selectors: [[\"\", \"swal\", \"\"]],\n    hostBindings: function SwalDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function SwalDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n    },\n    inputs: {\n      swal: \"swal\"\n    },\n    outputs: {\n      confirm: \"confirm\",\n      deny: \"deny\",\n      dismiss: \"dismiss\"\n    }\n  });\n  return SwalDirective;\n}();\n\nvar SwalPortalTargets = /*@__PURE__*/function () {\n  var SwalPortalTargets = function SwalPortalTargets() {\n    _classCallCheck(this, SwalPortalTargets);\n\n    /**\n     * Targets the modal close button block contents.\n     */\n    this.closeButton = {\n      element: function element(swal) {\n        return swal.getCloseButton();\n      },\n      options: {\n        showCloseButton: true\n      }\n    };\n    /**\n     * Targets the modal title block contents.\n     */\n\n    this.title = {\n      element: function element(swal) {\n        return swal.getTitle();\n      },\n      // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.\n      options: {\n        title: ' '\n      }\n    };\n    /**\n     * Targets the modal text block contents (that is another block inside the first content block, so you can still\n     * use other modal features like Swal inputs, that are situated inside that parent content block).\n     */\n\n    this.content = {\n      element: function element(swal) {\n        return swal.getHtmlContainer();\n      },\n      // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.\n      options: {\n        text: ' '\n      }\n    };\n    /**\n     * Targets the actions block contents, where are the confirm and cancel buttons in a normal time.\n     * /!\\ WARNING: using this target destroys some of the native SweetAlert2 modal's DOM, therefore, if you use this\n     *     target, do not update the modal via <swal> @Inputs while the modal is open, or you'll get an error.\n     *     We could workaround that inconvenient inside this integration, but that'd be detrimental to memory and\n     *     performance of everyone, for a relatively rare use case.\n     */\n\n    this.actions = {\n      element: function element(swal) {\n        return swal.getActions();\n      },\n      // The button will never exist, but SweetAlert2 shows the actions block only if there is at least one button.\n      options: {\n        showConfirmButton: true\n      }\n    };\n    /**\n     * Targets the confirm button contents, replacing the text inside it (not the button itself)\n     */\n\n    this.confirmButton = {\n      element: function element(swal) {\n        return swal.getConfirmButton();\n      },\n      options: {\n        showConfirmButton: true\n      }\n    };\n    /**\n     * Targets the deny button contents, replacing the text inside it (not the button itself)\n     */\n\n    this.denyButton = {\n      element: function element(swal) {\n        return swal.getDenyButton();\n      },\n      options: {\n        showDenyButton: true\n      }\n    };\n    /**\n     * Targets the cancel button contents, replacing the text inside it (not the button itself)\n     */\n\n    this.cancelButton = {\n      element: function element(swal) {\n        return swal.getCancelButton();\n      },\n      options: {\n        showCancelButton: true\n      }\n    };\n    /**\n     * Targets the modal footer contents.\n     */\n\n    this.footer = {\n      element: function element(swal) {\n        return swal.getFooter();\n      },\n      // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.\n      options: {\n        footer: ' '\n      }\n    };\n  };\n\n  SwalPortalTargets.ɵfac = function SwalPortalTargets_Factory(t) {\n    return new (t || SwalPortalTargets)();\n  };\n\n  SwalPortalTargets.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function SwalPortalTargets_Factory() {\n      return new SwalPortalTargets();\n    },\n    token: SwalPortalTargets,\n    providedIn: \"root\"\n  });\n  return SwalPortalTargets;\n}();\n\nvar SwalPortalComponent = /*@__PURE__*/function () {\n  var SwalPortalComponent = function SwalPortalComponent() {\n    _classCallCheck(this, SwalPortalComponent);\n\n    this.template = null;\n  };\n\n  SwalPortalComponent.ɵfac = function SwalPortalComponent_Factory(t) {\n    return new (t || SwalPortalComponent)();\n  };\n\n  SwalPortalComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: SwalPortalComponent,\n    selectors: [[\"swal-portal\"]],\n    inputs: {\n      template: \"template\"\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngTemplateOutlet\"]],\n    template: function SwalPortalComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, SwalPortalComponent_ng_container_0_Template, 1, 0, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template);\n      }\n    },\n    directives: [ɵngcc1.NgTemplateOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return SwalPortalComponent;\n}();\n\nvar SwalPortalDirective = /*@__PURE__*/function () {\n  var SwalPortalDirective = /*#__PURE__*/function () {\n    function SwalPortalDirective(resolver, injector, app, templateRef, sweetAlert2Loader, swalTargets, swalComponent) {\n      _classCallCheck(this, SwalPortalDirective);\n\n      this.resolver = resolver;\n      this.injector = injector;\n      this.app = app;\n      this.templateRef = templateRef;\n      this.sweetAlert2Loader = sweetAlert2Loader;\n      this.swalTargets = swalTargets;\n      this.swalComponent = swalComponent;\n      this.destroyed = new Subject();\n    }\n    /**\n     * Subscribes to the the SweetAlert appearance/disappearance events to create/destroy the SwalPortalComponent\n     * that will receive the consumer's template.\n     */\n\n\n    _createClass(SwalPortalDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        // Can't be set in a default property value, if the customer lets *swalPortal empty, the value we get is undef.\n        this.target = this.target || this.swalTargets.content; //=> Apply the options provided by the target definition\n\n        void this.swalComponent.update(this.target.options); //=> Subscribe to a few hooks frm the parent SwalComponent.\n\n        this.swalComponent.didRender.pipe(takeUntil(this.destroyed)).subscribe(this.didRenderHook.bind(this));\n        this.swalComponent.willOpen.pipe(takeUntil(this.destroyed)).subscribe(this.willOpenHook.bind(this));\n        this.swalComponent.didDestroy.pipe(takeUntil(this.destroyed)).subscribe(this.didDestroyHook.bind(this));\n      }\n      /**\n       * Signal any {@link destroyed} consumer that this is over, so they can unsubscribe from the\n       * parent SwalComponent events.\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.destroyed.next();\n      }\n      /**\n       * This didRender hook runs 1..n times (per modal instance), just before the modal is shown (and also before the\n       * {@link willOpenHook}), or after Swal.update() is called.\n       * This is a good place to render, or re-render, our portal contents.\n       */\n\n    }, {\n      key: \"didRenderHook\",\n      value: function didRenderHook() {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n          var swal, targetEl;\n          return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  //=> Ensure the portal component is created\n                  if (!this.portalComponentRef) {\n                    this.portalComponentRef = this.createPortalComponent();\n                  } //=> SweetAlert2 created the modal or just erased all of our content, so we need to install/reinstall it.\n                  // Swal.update() is synchronous, this observable too, and mountComponentOnTarget too (the promise inside\n                  // this function is already resolved at this point), so the whole process of re-rendering and re-mounting\n                  // the portal component is fully synchronous, causing no blinks in the modal contents.\n\n\n                  _context4.next = 3;\n                  return this.sweetAlert2Loader.swal;\n\n                case 3:\n                  swal = _context4.sent;\n                  //=> Find target element\n                  targetEl = this.target.element(swal);\n\n                  if (targetEl) {\n                    _context4.next = 7;\n                    break;\n                  }\n\n                  return _context4.abrupt(\"return\");\n\n                case 7:\n                  //=> Replace target's contents with our component\n                  // https://jsperf.com/innerhtml-vs-removechild/15\n                  while (targetEl.firstChild) {\n                    targetEl.removeChild(targetEl.firstChild);\n                  }\n\n                  targetEl.appendChild(this.portalComponentRef.location.nativeElement);\n\n                case 9:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, this);\n        }));\n      }\n      /**\n       * This willOpen hook runs once (per modal instance), just before the modal is shown on the screen.\n       * This is a good place to declare our detached view to the Angular app.\n       */\n\n    }, {\n      key: \"willOpenHook\",\n      value: function willOpenHook() {\n        if (!this.portalComponentRef) return; //=> Make the Angular app aware of that detached view so rendering and change detection can happen\n\n        this.app.attachView(this.portalComponentRef.hostView);\n      }\n      /**\n       * This didDestroy hook runs once (per modal instance), just after the modal closing animation terminated.\n       * This is a good place to detach and destroy our content, that is not visible anymore.\n       */\n\n    }, {\n      key: \"didDestroyHook\",\n      value: function didDestroyHook() {\n        if (!this.portalComponentRef) return; //=> Detach the portal component from the app and destroy it\n\n        this.app.detachView(this.portalComponentRef.hostView);\n        this.portalComponentRef.destroy();\n        this.portalComponentRef = void 0;\n      }\n      /**\n       * Creates the {@link SwalPortalComponent} and gives it the customer's template ref.\n       */\n\n    }, {\n      key: \"createPortalComponent\",\n      value: function createPortalComponent() {\n        //=> Create the SwalPortalComponent that will hold our content\n        var factory = this.resolver.resolveComponentFactory(SwalPortalComponent); // Yes, we do not use the third argument that would directly use the target as the component's view\n        // (unfortunately, because that would give a cleaner DOM and would avoid dirty and direct DOM manipulations)\n        // That's because we want to keep our component safe from SweetAlert2's operations on the DOM, and to be\n        // able to restore it at any moment, ie. after the modal has been re-rendered.\n\n        var componentRef = factory.create(this.injector, []); //=> Apply the consumer's template on the component\n\n        componentRef.instance.template = this.templateRef;\n        return componentRef;\n      }\n    }]);\n\n    return SwalPortalDirective;\n  }();\n\n  SwalPortalDirective.ɵfac = function SwalPortalDirective_Factory(t) {\n    return new (t || SwalPortalDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(SweetAlert2LoaderService), ɵngcc0.ɵɵdirectiveInject(SwalPortalTargets), ɵngcc0.ɵɵdirectiveInject(SwalComponent, 1));\n  };\n\n  SwalPortalDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SwalPortalDirective,\n    selectors: [[\"\", \"swalPortal\", \"\"]],\n    inputs: {\n      target: [\"swalPortal\", \"target\"]\n    }\n  });\n  return SwalPortalDirective;\n}();\n\nfunction provideDefaultSwal() {\n  return import('sweetalert2');\n}\n\nvar SweetAlert2Module = /*@__PURE__*/function () {\n  var SweetAlert2Module = /*#__PURE__*/function () {\n    function SweetAlert2Module() {\n      _classCallCheck(this, SweetAlert2Module);\n    }\n\n    _createClass(SweetAlert2Module, null, [{\n      key: \"forRoot\",\n      value: function forRoot() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return {\n          ngModule: SweetAlert2Module,\n          providers: [SweetAlert2LoaderService, {\n            provide: swalProviderToken,\n            useValue: options.provideSwal || provideDefaultSwal\n          }, {\n            provide: fireOnInitToken,\n            useValue: options.fireOnInit || false\n          }, {\n            provide: dismissOnDestroyToken,\n            useValue: options.dismissOnDestroy || true\n          }]\n        };\n      }\n    }, {\n      key: \"forChild\",\n      value: function forChild() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return {\n          ngModule: SweetAlert2Module,\n          providers: [].concat(_toConsumableArray(options.provideSwal ? [SweetAlert2LoaderService, {\n            provide: swalProviderToken,\n            useValue: options.provideSwal\n          }] : []), _toConsumableArray(options.fireOnInit !== undefined ? [{\n            provide: fireOnInitToken,\n            useValue: options.fireOnInit\n          }] : []), _toConsumableArray(options.dismissOnDestroy !== undefined ? [{\n            provide: dismissOnDestroyToken,\n            useValue: options.dismissOnDestroy\n          }] : []))\n        };\n      }\n    }]);\n\n    return SweetAlert2Module;\n  }();\n\n  SweetAlert2Module.ɵfac = function SweetAlert2Module_Factory(t) {\n    return new (t || SweetAlert2Module)();\n  };\n\n  SweetAlert2Module.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: SweetAlert2Module\n  });\n  SweetAlert2Module.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return SweetAlert2Module;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SweetAlert2Module, {\n    declarations: function declarations() {\n      return [SwalDirective, SwalComponent, SwalPortalDirective, SwalPortalComponent];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [SwalComponent, SwalPortalDirective, SwalDirective];\n    }\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { SwalComponent, SwalDirective, SwalPortalDirective, SwalPortalTargets, SweetAlert2LoaderService, SweetAlert2Module, provideDefaultSwal as ɵa, swalProviderToken as ɵb, fireOnInitToken as ɵc, dismissOnDestroyToken as ɵd, SwalPortalComponent as ɵe }; //# sourceMappingURL=sweetalert2-ngx-sweetalert2.js.map","map":null,"metadata":{},"sourceType":"module"}